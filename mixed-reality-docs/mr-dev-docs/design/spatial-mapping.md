---
title: 空间映射
description: 空间映射提供了在 HoloLens 环境中实际表面的详细表示。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射，HoloLens，混合现实，表面重建，网格，混合现实耳机，windows mixed reality 耳机，虚拟现实耳机，HoloLens，MRTK，混合现实工具包，场景理解，世界网格，封闭，物理学，导航，表面观察器，渲染，网格处理
ms.openlocfilehash: 448c64a6c19ee96d58be9a14f7ea4c34a755695e
ms.sourcegitcommit: 4f3ef057a285be2e260615e5d6c41f00d15d08f8
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/17/2020
ms.locfileid: "94703313"
---
# <a name="spatial-mapping"></a>空间映射

空间映射提供了针对 HoloLens 环境中实际表面表面的详细表示，使开发人员能够创建一个具有说服力混合的现实体验。 通过将现实世界与虚拟世界合并，应用程序可以使全息影像看起来非常真实。 应用程序通过提供熟悉的实际行为和交互，还可以更自然地与用户的预期保持一致。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>设备支持

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><strong>功能</strong></td>
        <td><a href="../hololens-hardware-details.md"><strong>HoloLens（第 1 代）</strong></a></td>
        <td><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></td>
        <td><a href="../discover/immersive-headset-hardware-details.md"><strong>沉浸式头戴显示设备</strong></a></td>
    </tr>
     <tr>
        <td>空间映射</td>
        <td>✔️</td>
        <td>✔️</td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a>为什么空间映射很重要？

利用空间映射，可以将对象放置在真实的图面上。 这有助于在用户世界定位对象，并利用真实的深度提示。基于其他全息影像和现实世界对象 Occluding 全息影像有助于说服用户这些全息影像实际位于其空间中。 在空间中浮动或随用户移动的全息影像并不真实。 如果可能，可轻松放置项目。

放置或移动全息影像时显示表面 (使用简单的投影网格) 。 这将帮助用户了解他们最能最好地放置全息影像，并在用户尝试放置全息影像的位置上显示用户。 如果用户的角度太多，您可以向用户 "布告栏项目"。

## <a name="conceptual-overview"></a>概念概述

![覆盖房间的网格面](images/SurfaceReconstruction.jpg)<br>
*覆盖房间的空间映射网格示例*

用于空间映射的两个主要对象类型为 "空间图观察器" 和 "空间图面"。

应用程序为空间图面观察器提供一个或多个边界卷，以定义应用程序希望接收空间映射数据的空间区域。 对于每个卷，空间映射将为应用程序提供一组空间图面。

这些卷可能在固定位置 (固定位置，与现实世界) 不同，或者它们可能附加到 HoloLens (，但在通过环境) 的情况下，也可能会将其附加到 hololens。 每个空间图面都描述了小空间中的实际表面，表示为附加到世界锁定的 [空间坐标系统](coordinate-systems.md)的三角形网格。

当 HoloLens 收集有关环境的新数据时，如果对环境进行了更改，空间图面将显示、消失和变化。

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a>空间映射与场景理解 WorldMesh
对于 HoloLens 2，可以使用 [场景理解 SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 设置) 来查询空间映射数据的静态版本。 下面是访问空间映射数据的两种方法之间的差异：
* 空间映射 API：
   * 有限范围：用户可使用大小受限的应用程序的空间映射数据。
   * 通过 SurfacesChanged 事件提供更改的网格区域的低延迟更新。
   * 每个立方计量参数的三角形控制的详细信息级别。
* 场景理解 SDK：
   * 无限制范围-提供查询半径内所有扫描的空间映射数据。
   * 提供空间映射数据的静态快照。 获取更新的空间映射数据需要对整个网格运行新的查询。
   * RequestedMeshLevelOfDetail 设置控制的详细级别的详细信息。

## <a name="what-influences-spatial-mapping-quality"></a>哪些因素会影响空间映射质量？

[此处](../environment-considerations-for-hololens.md)详细介绍的几个因素可能会影响这些错误的频率和严重性。  但是，你应设计应用程序，以便即使在空间映射数据中存在错误时，用户也能够实现其目标。

## <a name="common-usage-scenarios"></a>常见使用方案

![常见空间映射使用方案的插图：放置、封闭、物理学和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空间映射为应用程序提供了向用户提供自然和熟悉的交互形式的机会。比将电话向下移动电话的情况如何？

 (或更常见地限制全息影像的位置，) 的任何空间位置选择都是在表面上，从空间) 的 3D (点到图面 (上的 2D) 点的自然映射。 这会减少用户提供给应用程序所需的信息量，进而使用户的交互速度更快、更简单且更精确。 这种情况特别适用，因为 "距离远离" 不是我们用于与其他人或计算机进行物理通信的内容。 当我们使用手指点时，我们指定的是一个方向，而不是距离。

此处的一个重要注意事项是，当应用程序从方向推断距离时 (例如，沿用户的注视方向执行 raycast 以查找最接近的空间图面) ，这必须生成用户能够可靠预测的结果。 否则，用户将失去控制，这很快就会变得沮丧。 有助于实现此功能的一种方法是执行多个 raycasts，而不是只执行一个。 聚合结果应更平滑且更具可预测性，不会受到暂时性 "离群" 结果的影响 (因为这可能是由于光线通过小孔而导致用户不知道) 的小位几何导致的。 还可以在一段时间内执行聚合或平滑处理;例如，可以限制每个用户与用户之间的距离变化的最大速度。 只是限制最小值和最大距离值也很有帮助，因此，要移动的全息影像不会突然飞入到远处，也不会发生故障。

应用程序还可以使用图面的形状和方向来指导全息图放置。 全息椅子不应穿透墙壁，并应与地面齐平，即使它略有变化。 这种功能可能会依赖于使用物理学冲突而不只是 raycasts，但会应用类似的问题。 如果放置的全息图包含许多小多边形，如椅子上的支线，则将这些多边形的物理表示形式扩大到更宽和更平滑的位置，使其更能在无适合的情况下滑过空间图面。

在其极端情况下，用户输入可以完全被简化，空间表面可用于执行完全自动的全息影像放置。 例如，应用程序可能会在墙壁的某个位置放置一个全息片开关，以便用户按下。 与可预测性相同的注意事项也适用于：如果用户需要控制全息图放置，但是应用程序不会始终在其预期的位置放置全息影像 (如果光交换机出现在用户无法访问) 的某个位置，这将是一项令人沮丧的体验。 它实际上可能更糟地执行需要用户更正的自动放置，而不是只要求用户始终执行放置;由于 *预期* 的自动放置成功，手动更正就像是一种负担！

另请注意，应用程序使用空间表面进行放置的能力很大程度上取决于应用程序的 [扫描体验](spatial-mapping.md#the-environment-scanning-experience)。 如果尚未扫描图面，则它不能用于放置。 这是由应用程序为用户提供的，因此，他们可以帮助扫描新的表面或选择新的位置。

在放置过程中，对用户的视觉反馈非常重要。 用户需要知道全息图与最接近的图面之间的关系，并具有 [接地效果](spatial-mapping.md#visualization)。 它们应了解为什么会对全息图的移动进行约束 (例如，因为与附近的另一个曲面) 发生冲突。 如果它们无法在当前位置放置全息影像，则视觉对象反馈应清楚地说明为什么不这样做。 例如，如果用户尝试将全息的沙发卡在墙壁上，则墙后的沙发部分应 pulsate 为生气的颜色，。 相反地，如果应用程序在用户可以看到真实表面的位置找不到空间图面，则应用程序应如此清晰。 此区域中明显不会产生接地效果的情况。

### <a name="occlusion"></a>封闭

空间映射图面的主要用途之一就是遮蔽全息影像。 这一简单的行为对全息影像的明显影响非常大，有助于创建 visceral 的意义，真正与用户具有相同的物理空间。

封闭还向用户提供信息;当真实的图面看不封闭像素全息图时，这将向世界上该全息图的空间位置提供更多的视觉反馈。 相反，封闭也可以有用 *隐藏* 用户的信息;occluding 的后台影像可以以直观的方式减少视觉干扰。 若要隐藏或显示全息图，用户只需移动其头。

封闭还可用于根据熟悉的物理交互，为自然用户界面提供合理的预期。如果某个图面的封闭像素是一个全息图，就是因为该表面是稳定的，因此用户应该认为这种影像将与该表面发生 *冲突* ，而不只是通过它。

有时，不需要封闭的全息影像。 如果用户需要能够与全息图交互，则他们需要能够看到它，即使它位于实际的表面上。 在这种情况下，在封闭像素 (例如，通过降低亮度) ，可以不同的方式呈现此类全息图。 这样一来，用户将能够以可视方式找到全息图，但仍会注意到它位于某个地方。

### <a name="physics"></a>物理

使用物理学模拟的另一种方法是使用空间映射来强化用户物理空间中 *是否存在* 全息影像。 当我的全息橡胶球从真实上掷走，弹跳在床上并消失后，我很难相信它并不真正。

物理学模拟还为应用程序提供了使用自然和熟悉的基于物理学的交互的机会。 如果家具的响应方式与在楼层间滑动，并具有适当的惯性和摩擦，则用户可能会更容易地在地面上移动一张全息的家具。

为了生成真实的物理行为，你可能需要执行一些 [网格处理](spatial-mapping.md#mesh-processing) ，如填充孔、删除浮动 hallucinations 和平滑表面。

还需要考虑应用程序的 [扫描体验](spatial-mapping.md#the-environment-scanning-experience) 如何影响其物理模拟。 首先，缺少的图面不会与任何内容发生冲突;当橡胶球向下 corridor 并从已知世界结束时，会发生什么情况呢？ 其次，您需要确定是否将在一段时间内继续对环境中的更改做出响应。 在某些情况下，你需要尽快做出响应;例如，如果用户使用门和家具作为 barricades 中的可移动的 tempest，则不会出现传入罗马字箭头的。 但在其他情况下，你可能想要忽略新的更新;如果狗决定坐在轨迹的中间，则围绕地面的 racetrack 推动您的全息运动汽车就会突然不那么有趣。

### <a name="navigation"></a>导航

应用程序可以使用空间映射数据 (或代理授予全息字符，) 能够以真实人员的相同方式浏览现实。 这可以通过将其限制为用户及其好友的一组自然、熟悉的行为来帮助强化是否存在全息字符。

导航功能对于用户也很有用。 在给定区域中生成导航地图后，可以将其共享，为不熟悉该位置的新用户提供全息说明。 此映射可用于帮助保持行人的流量顺畅地流动，或避免在危险位置（如构造站点）中发生意外。

实现导航功能所涉及的关键技术挑战将会对不可的表面进行可靠检测， (人们不会对表进行检查！ ) 并正常地适应环境中的变化 (人类不会遍历关闭的门！ ) 。 网格可能需要进行一些 [处理](spatial-mapping.md#mesh-processing) 才能用于通过虚拟字符进行路径规划和导航。 平滑网格和删除 hallucinations 可帮助避免字符停滞。 您还可能希望大幅简化网格，以加快字符的路径规划和导航计算速度。 在开发 videogame 技术时，这些挑战已经获得了很大的关注，其中提供了大量有关这些主题的信息。

请注意，Unity 中的内置 NavMesh 功能不能与空间映射图面一起使用。 这是因为在应用程序启动之前空间映射表面是未知的，而需要提前从源资产生成 NavMesh 数据文件。 另请注意，空间映射系统不会提供与用户当前位置 [有关的有关表面的信息](spatial-mapping.md#the-environment-scanning-experience) 。 因此，如果应用程序要生成非常大的区域的地图，则必须 "记住" 自己的图面。

### <a name="visualization"></a>可视化效果

大多数情况都适用于空间图面不可见;为了最大程度地减少视觉干扰，并让现实世界亲自讲述。 但是，有时可以直接直观显示空间图图面，尽管它们的实际对应项已经可见。

例如，当用户尝试在墙壁上放置全息式柜子时， (会将一只全息文件柜放到图面上时，假设) 通过将阴影转换到图面上来 "接地"。 这样，用户就可以更清楚地了解全息图和表面之间的确切物理距离。 这也是在用户提交到用户之前，直观地预览更改的更通用的示例。

通过可视化图面，应用程序可以与用户共享其环境的了解。 例如，全息板游戏可能会将其标识为 "表" 的水平表面可视化，因此用户知道应该在何处交互。

可视化图面可用于向用户显示在视图中隐藏的附近的用户。 这可能会提供一种简单的方法，使用户能够从其客厅中访问其厨房 (及其包含的所有全息影像) 。

空间映射提供的 surface 网格可能不是特别 "干净的"。 因此，对其进行适当的可视化非常重要。 传统的照明计算可能会以视觉上分散的方式突出显示曲面法线中的错误，而投影到表面的 "干净" 纹理可能有助于使其成为整齐的外观。 在呈现表面之前，还可以执行 [网格处理](spatial-mapping.md#mesh-processing) 来改善网格属性。

> [!NOTE]
> HoloLens 2 实现了一种新的 [场景了解运行时](scene-understanding.md)，它为混合现实开发人员提供了一个结构化、高级别的环境表示形式，旨在简化放置、封闭、物理学和导航的实现。

## <a name="using-the-surface-observer"></a>使用 Surface 观察器

空间映射的起始点为 surface 观察程序。 程序流如下所示：
* 创建 surface 观察器对象
   * 提供一个或多个空间卷，以定义应用程序希望接收空间映射数据的感兴趣的区域。 空间量只是定义空间区域的形状，例如球或 box。
   * 使用带有世界锁定的空间坐标系统的空间量来识别物理世界的固定区域。
   * 使用空间量，使用正文锁定的空间坐标系统更新每个帧，以标识移动 (但不会向用户旋转) 的空间区域。
   * 以后可以随时更改这些空间卷，因为应用程序或用户的状态会发生更改。
* 使用轮询或通知来检索有关空间图面的信息
   * 您可以随时 "轮询" 面观察器来实现空间图面状态。 或者，你可以为 surface 观察器的 "surface changed" 事件注册，这会在空间表面发生更改时通知应用程序。
   * 对于动态空间量（如视图截锥或正文锁定卷），应用程序需要通过设置感兴趣的区域，然后获取当前的空间图面集来轮询每个帧的更改。
   * 对于静态卷（如涵盖单个房间的全球锁定的多维数据集），应用程序可能会注册 "已更改" 事件，以便在该卷内的空间表面发生变化时得到通知。
* 处理表面更改
   * 循环访问提供的空间图面集。
   * 按添加、更改或删除的方式对空间图面进行分类。
   * 对于每个已添加或已更改的空间图面，如果适当，请提交一个异步请求，以在所需的详细信息级别接收表示该图面的当前状态的已更新网格。
* )  (以下部分中的详细信息，处理异步网格请求。

## <a name="mesh-caching"></a>网格缓存

空间图面由密集三角形网格表示。 存储、呈现和处理这些网格可能会占用大量计算和存储资源。 因此，每个应用程序应采用适合于其需要的网格缓存方案，以最大程度地减少用于网格处理和存储的资源。 此方案应该确定要保留哪些网格以及要丢弃哪些网格，以及何时更新每个空间图面的网格。

其中所述的许多注意事项将直接通知您的应用程序应该如何处理网格缓存。 当观察到不同的表面以及应捕获环境中的更改时，您应考虑用户在环境中的移动方式、需要的表面。

当解释 surface 观察器提供的 "表面变化" 事件时，基本网格缓存逻辑如下所示：
* 如果应用程序看到之前未出现过的空间表面 ID，则它应将其视为新的空间图面。
* 如果应用程序看到具有已知 ID 但具有新更新时间的空间图面，则它应将其视为更新的空间图面。
* 如果应用程序不再看到具有已知 ID 的空间图面，则它应将其视为已删除的空间图面。

在每个应用程序中，然后进行以下选择：
* 对于新空间图面，是否应请求网格？
   * 通常应立即为新的空间图面请求网格，这可能会向用户提供有用的新信息。
   * 但是，在用户面前附近和之前的新空间图面应优先，并首先请求其网格。
   * 如果不需要新网格，则为; 例如，如果应用程序永久或临时 "冻结" 其环境模型，则不应请求它。
* 对于已更新的空间图面，是否应请求网格？
   * 应将已更新的空间图面置于用户面前，并应首先请求其网格。
   * 对于新曲面，更高优先级的优先级可能更高，特别是在扫描体验过程中。
   * 为了限制处理成本，应用程序可能希望限制它们处理空间图面更新的速率。
   * 可以推断出对空间图面所做的更改很小，例如，如果图面的边界很小，则更新可能不太重要，无法处理。
   * 对于用户感兴趣的当前区域之外的空间表面的更新，可能会完全忽略，但是在这种情况下，修改 surface 观察器使用的空间边界卷可能更有效。
* 对于删除的空间表面，是否应丢弃网格？
   * 通常应为删除的空间图面立即丢弃网格，使全息图封闭保持正确。
   * 但是，如果应用程序有理由相信某个空间图面很快就会重新出现 (可能基于用户体验的设计) ，则保留它比丢弃其网格并稍后重新创建它更有效。
   * 如果应用程序正在生成用户环境的大规模模型，则可能不希望全部丢弃任何网格。 不过，它仍需要限制资源使用情况，可能通过将网格后台打印到磁盘，因为空间图面消失。
   * 请注意，在空间表面生成过程中，某些相对罕见的事件可能会导致空间图面替换为类似位置但 Id 不同的新空间图面。 因此，选择不放弃已移除表面的应用程序应注意不会有多个高度重叠的空间表面网格覆盖同一位置。
* 是否应为任何其他空间图面丢弃网格？
   * 即使存在空间图面，如果它对用户体验不再有用，则应将其丢弃。 例如，如果应用程序 "将门口的另一侧的空间替换为备用虚拟空间，则该房间中的空间表面将不再重要。

下面是使用空间和时态滞后的示例网状缓存策略：
* 假设有一个应用程序，该应用程序想要在观看和四处浏览时使用在用户的 "注视" 周围的 "截锥" 空间量。
* 空间表面可能会暂时从此卷中消失，这只是因为用户看起来远离图面或其他步骤 .。。仅供稍后再次查找或更近一段时间。 在这种情况下，放弃并重新创建此图面的网格表示大量冗余处理。
* 为了减少处理的更改的数量，应用程序将使用两个空间图面观察器，其中一个包含在另一个中。 较大的卷为球状，并跟随用户 "延迟";它仅在必要时才会移动，以确保其中心在用户的 2.0 metres 范围内。
* 新的和更新的空间 surface 网格始终从较小的内部面观察程序进行处理，但会缓存网格，直到它们从较大的外部表面观察器消失。 这使应用程序可以避免因本地用户移动而处理许多冗余更改。
* 由于由于跟踪丢失，空间图面也可能暂时消失，因此，应用程序也会在跟踪丢失期间放弃删除的空间图面。
* 通常情况下，应用程序应评估减少的更新处理和增加的内存使用情况之间的折衷，以确定其理想的缓存策略。

## <a name="rendering"></a>渲染

空间映射网格通常用于呈现的主要方式有三种：
* 用于表面可视化
   * 它通常有助于直接可视化空间图面。 例如，将 "shadows" 从对象强制转换为空间图面时，可以向用户提供更好的视觉反馈。
   * 需要注意的一点是，空间网格不同于三维艺术家可能创建的网格类型。 三角形拓扑不会作为用户创建的拓扑 "干净"，并且网格会受到 [各种错误](spatial-mapping.md#what-influences-spatial-mapping-quality)的影响。
   * 为了创建令人满意的视觉对象美观，可能需要执行一些 [网格处理](spatial-mapping.md#mesh-processing)，例如填充孔或平滑曲面法。 您还可能希望使用着色器将艺术家设计的纹理投影到网格上，而不是直接可视化网格拓扑和法线。
* 对于真实的图面后面的 occluding 全息影像
   * 空间图面可以在仅深度传递中呈现，这只会影响 [深度缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) 并且不会影响颜色呈现器目标。
   * 这会 primes 深度缓冲区以遮蔽随后呈现的空间表面上呈现的全息影像。 最准确的全息影像封闭增强了全息影像在用户的物理空间内确实存在的意义。
   * 若要启用仅深度渲染，请更新混合状态，将所有颜色渲染目标的 [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) 设置为零。
* 用于修改真实环境中全息图封闭像素的外观
   * 当封闭像素时，通常会隐藏呈现的几何图形。 这是通过将 [深度-模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) 中的深度函数设置为 "小于或等于" 来实现的，这会使几何仅在 **离相机更近** 的位置（而不是所有先前呈现的几何图形）可见。
   * 但是，即使在封闭像素时仍可查看某些几何，并在封闭像素作为向用户提供视觉反馈的方式时修改其外观，这可能会很有用。 例如，这允许应用程序向用户显示对象的位置，同时使其清楚地显示在实际表面。
   * 若要实现此目的，请使用另一个创建所需 "封闭像素" 外观的着色器第二次渲染几何。 在第二次渲染几何之前，对 [深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)进行两次更改。 首先，将 "深度函数" 设置为 "大于或等于"，以便仅在其从相机中的 **其他** 位置（而不是所有先前呈现的几何图形）中可见。 其次，将 DepthWriteMask 设置为零，以便不会修改深度缓冲区 (深度缓冲区应继续表示距离相机) **最近** 的几何深度。

在呈现空间映射网格时，[性能](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)是一个重要的考虑因素。 下面是一些特定于呈现空间映射网格的呈现性能技巧：
* 调整三角形密度
   * 从 surface 观察者请求空间表面网格时，请求可满足您需求的最小的三角形网格密度。
   * 在图面上改变三角密度可能有意义，具体取决于表面与用户的距离以及与用户体验的相关性。
   * 减少三角形计数将减少 GPU 上的内存使用量和顶点处理开销，但它不会影响像素处理开销。
* 执行截锥剔除
   * 截锥剔除会跳过无法看见的绘图对象，因为它们在当前显示的 "截锥" 之外。 这同时降低了 CPU 和 GPU 处理成本。
   * 由于在每个网格基础上执行剔除，空间表面可能会很大，因此将每个空间曲面网格分割为较小的区块可能会导致更有效的剔除 (，因为) 会呈现较少的屏幕外三角形。 不过，有一种折衷：您拥有的网格越多，您必须进行的绘图调用越多，这会增加 CPU 开销。 在极端情况下，如截锥剔除计算，甚至可能有可度量的 CPU 开销。
* 调整呈现顺序
   * 空间表面很大，因为它们代表用户在周围的整个环境。 GPU 上的像素处理开销可能很高，尤其是在有多层可见的几何图形 (包括空间表面和其他全息影像) 的情况下。 在这种情况下，离用户最近的层会进一步 occluding 任何层，因此，在呈现这些更远距离的层所用的任何 GPU 时间都将浪费下来。
   * 若要减少 GPU 上的这一冗余工作，这有助于在最接近的情况下，以从上到下的顺序呈现不透明的图面， (上一次) 。 "不透明" 是指在您的 [深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中将 DepthWriteMask 设置为一个的表面。 当呈现最近的图面时，它们将成为深度缓冲区的质数，以便 GPU 上的像素处理器有效地跳过更远的图面。

## <a name="mesh-processing"></a>网格处理

应用程序可能希望对空间 surface 网格执行 [各种操作](spatial-mapping.md#mesh-processing) 以满足其需求。 每个空间 surface 网格提供的索引和顶点数据与用于在所有新式渲染 Api 中呈现三角形网格的 [顶点和索引缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) 使用的布局相同。 不过，有一个关键事实需要注意的是，空间映射三角形具有 **前后的缠绕顺序**。 每个三角形都用网格的索引缓冲区中的三个顶点索引表示，当从 **正面** 查看三角形时，这些索引会按 **顺时针** 顺序标识三角形的顶点。 空间 surface 网格的正面 (或外部) 与您预期在实际表面的正面 () 可见。

如果表面观察器提供的益处三角形密度仍不足较粗，则应用程序应仅执行网格简化，这种工作的计算成本高昂，并且已经由运行时执行以生成各种提供的详细信息级别。

由于每个 surface 观察器都可以提供多个未连接的空间图面，因此某些应用程序可能希望彼此剪裁这些空间 surface 网格，然后将它们 zipper 在一起。 通常，剪裁步骤是必需的，因为附近的空间 surface 网格通常会稍微重叠。

## <a name="raycasting-and-collision"></a>Raycasting 和冲突

为了使物理学 API (例如 [Havok](https://www.havok.com/)) 为应用程序提供具有 raycasting 和冲突功能的空间图面，应用程序必须向物理学 api 提供空间 surface 网格。 用于物理学的网格通常具有以下属性：
* 它们只包含少量三角形。 物理运算比呈现操作要多得多。
* 它们是 "水紧的"。 应为实心的表面不应具有小孔;即使洞太小，也可能会导致问题。
* 它们将转换为凸 hulls。 凸 hulls 有几个多边形，并且没有孔，它们的计算效率比原始三角形网格要高得多。

针对空间图面执行 raycasts 时，请记住，这些图面通常是复杂的、杂乱的形状，几乎不会有杂乱的细节，就像您的办公桌一样！ 这意味着，单个 raycast 通常不能为您给出有关图面的形状和附近的空白空间形状的足够信息。 因此，通常最好在一个较小的区域中执行许多 raycasts，并使用聚合结果来更可靠地了解图面。 例如，使用平均 10 raycasts 来指导图面上的全息影像布局将产生比只使用单个 raycast 更流畅和更小的 "抖动" 结果。

不过，请记住，每个 raycast 都有一个较高的计算成本。 因此，根据您的使用情况，您应权衡 (每个帧) 执行的其他 raycasts 的计算成本，使其在空间网格 () 更新后执行 [，以平滑](spatial-mapping.md#mesh-processing) 和删除空间图面中的孔。

## <a name="the-environment-scanning-experience"></a>环境扫描体验

使用空间映射的每个应用程序都应考虑提供 "扫描体验";应用程序引导用户扫描应用程序正常运行所必需的表面所使用的过程。

![扫描示例](images/sr-mixedworld-140429-8pm-00068-1000px.png)<br>
*扫描示例*

此扫描体验的性质可能因每个应用程序的需求而有很大差别，但两个主要原则应指导其设计。

首先， **清除与用户的通信是主要关注** 点。 用户应始终知道是否满足应用程序的要求。 如果不满足这些要求，则应该立即清楚地说明这种情况的原因，并且应迅速采取适当的措施。

其次， **应用程序应尝试在效率和可靠性之间取得平衡**。 如果可以 **可靠地** 执行此操作，则应用程序应自动分析空间映射数据以节省用户时间。 如果无法可靠地执行此操作，则应用程序应改为允许用户使用其所需的其他信息快速提供应用程序。

若要帮助设计正确的扫描体验，请考虑以下哪些可能适用于你的应用程序：

* **无扫描体验**
   * 如果没有任何引导式扫描体验，应用程序可以正常工作;它将了解在自然用户移动过程中观察到的图面。
   * 例如，允许用户在带有全息喷涂画图的表面上绘图的应用程序只需要知道当前对用户可见的表面。
   * 如果环境中的用户已使用 HoloLens 花费了大量时间，则可能会完全扫描该环境。
   * 请记住，空间映射使用的相机只能在用户前面看到 3.1 m，因此，空间映射将不知道任何更远的图面，除非用户在过去从更远的距离观察到它们。
   * 因此，用户了解已经扫描了哪些表面，应用程序应提供此效果的视觉反馈，例如，将虚拟阴影转换到扫描图面上可能会帮助用户在这些表面上放置全息影像。
   * 对于这种情况，应将空间图面观察器的边界卷更新为主体锁定的 [空间坐标系统](coordinate-systems.md)，使其跟随用户。

* **查找合适的位置**
   * 应用程序可设计为在具有特定要求的位置使用。
   * 例如，应用程序可能需要用户附近的空白区域，以便他们能够安全地练习全息 kung-fu。
   * 应用程序应提前向用户传达任何特定要求，并通过清晰的视觉反馈来强化。
   * 在此示例中，应用程序应可视化所需空区域的范围，并以可视方式突出显示此区域内任何不需要的对象的状态。
   * 对于这种情况，空间图面观察器的边界卷应在所选位置使用世界锁定的 [空间坐标系统](coordinate-systems.md) 。

* **查找图面的合适配置**
   * 应用程序可能需要特定的图面配置，例如两个大型、平整、相反的壁，以创建全息的镜像厅。
   * 在这种情况下，应用程序需要对空间映射提供的图面进行分析以检测适当的图面，并将用户定向到它们。
   * 如果应用程序的表面分析不完全可靠，用户应具有回退选项。 例如，如果应用程序错误地将门口标识为平整壁，则用户需要一种简单的方法来更正此错误。

* **扫描部分环境**
   * 应用程序可能希望只捕获用户所指示的部分环境。
   * 例如，应用程序会扫描房间的某个部分，以使用户可以为想要销售的家具发布全息保密广告。
   * 在这种情况下，应用程序应该捕获用户在扫描期间观察到的区域内的空间映射数据。

* **扫描整个聊天室**
   * 应用程序可能需要扫描当前房间中的所有表面，包括用户之后的所有表面。
   * 例如，游戏可能将用户作为 Gulliver 的角色，在 siege 中，从数百个微小 Lilliputians 接近所有方向。
   * 在这种情况下，应用程序需要确定当前房间中已经扫描了多少个面，并指示用户的注视填充了重大间隙。
   * 此过程的关键是提供可视反馈，使用户清楚地知道尚未扫描哪些表面。 应用程序可以使用 [基于距离的雾化](https://msdn.microsoft.com/library/windows/desktop/bb173401%28v=vs.85%29.aspx) 来以可视方式突出显示空间映射图面未涵盖的区域。

* **获取环境的初始快照**
   * 在采用初始 "快照" 后，应用程序可能希望忽略环境中的所有更改。
   * 这可能适用于避免与环境中的初始状态紧密耦合的用户创建数据的中断。
   * 在这种情况下，在扫描完成后，应用程序应在其初始状态下生成空间映射数据的副本。
   * 如果在环境中仍有封闭像素，则应用程序应继续接收空间映射数据的更新。
   * 对于空间映射数据的持续更新，还允许对已发生的任何更改进行可视化，并向用户阐明环境以前和当前状态之间的差异。

* **采用用户启动的环境快照**
   * 应用程序可能只希望在用户指示时对环境更改做出响应。
   * 例如，用户可以通过在不同时刻捕获其姿势来创建多个 3D "statues"。

* **允许用户更改环境**
   * 应用程序可用于实时响应用户环境中所做的任何更改。
   * 例如，如果在另一侧发生全息部游戏，则用户绘制窗帘可能会触发 "场景变化"。

* **指导用户避免空间映射数据中的错误**
   * 在用户扫描其环境时，应用程序可能希望向用户提供指导。
   * 这可以帮助用户避免 [空间映射数据中](spatial-mapping.md#what-influences-spatial-mapping-quality)出现某些类型的错误，例如，远离 sunlit windows 或镜像。

需要注意的另一个细节是，空间映射数据的 "范围" 是不受限制的。 虽然空间映射确实生成了大量空间的永久数据库，但它只会使该数据可用于用户周围大小限制较小的应用程序。 因此，如果从较长的 corridor 开始，到离开始时间起，最终空间表面就会消失。 当然，您可以通过在应用程序从可用空间映射数据中消失后将它们缓存在您的应用程序中来缓解这种情况。

## <a name="mesh-processing"></a>网格处理

它可能有助于检测图面中的常见错误类型，并根据需要对空间映射数据进行筛选、删除或修改。

请记住，空间映射数据应尽可能忠实到实际的表面，因此，任何正在进行的处理都将进一步从 "真实" 改变你的曲面。

下面是一些可能有用的不同类型网格处理的示例：

* **孔洞填充**
   * 如果导致暗材料的小对象无法扫描，它将在周围表面上留下一个孔。
   * 孔洞会影响封闭：在被视为不透明的实际表面，可以通过 "通过" 洞来查看全息影像。
   * 孔洞会影响 raycasts：如果使用 raycasts 帮助用户与表面交互，则这些光线可能不需要通过洞。 一种缓解措施是使用多个 raycasts 的捆绑，涵盖适当大小的区域。 这将允许你筛选 "离群离群" 结果，这样即使一个 raycast 通过一个小孔，聚合结果仍将有效。 但请注意，这种方法会产生计算成本。
   * 孔洞会影响物理学冲突：物理学模拟控制的对象可能会贯穿地面的孔，并会丢失。
   * 可以算法在 surface 网格中填充此类孔。 但是，您将需要优化算法，以便不会填充 "real 洞"，如 windows 和两侧。 很难可靠地区分 "实孔" 与 "虚部"，因此您需要试验不同的试探法，例如 "大小" 和 "边界形状"。

* **删除 Hallucination**
   * 反射、明亮灯光和移动对象可能会使小延迟 "hallucinations" 浮动在空中。
   * Hallucinations 影响封闭： Hallucinations 可能会成为深色形状，并将其移到上，并 occluding 其他全息影像。
   * Hallucinations 影响 raycasts：如果你使用 raycasts 帮助用户与表面交互，则这些光线可能会碰到 hallucination，而不是其背后的表面。 与孔洞一样，一种缓解措施是使用许多 raycasts，而不是使用单个 raycast，但这会产生计算成本。
   * Hallucinations 影响物理学冲突：物理学模拟控制的对象可能会停滞在 hallucination 的位置，并且无法在看似清晰的空间区域中移动。
   * 可以从 surface 网格筛选此类 hallucinations。 但是，与孔洞一样，你需要调整算法，使真实的小对象（如灯具和门控点）不会被删除。

* **光滑**
   * 空间映射可能会返回与实际对应项相比显得非常粗糙或 "干扰" 的表面。
   * 平滑度会影响物理学冲突：如果地面为粗糙，则物理模拟的高尔夫球可能不会以直线平滑地滚动。
   * 平滑度会影响呈现：如果图面直接可视化，则视觉表面的法线会影响其外观并干扰 "干净" 的外观。 可以通过使用着色器中用于呈现图面的适当照明和纹理来缓解这种情况。
   * 可以在 surface 网格中平滑粗糙度。 但是，这可能会使表面远离相应的实际表面。 维护近函件对于生成准确的全息图封闭非常重要，并使用户能够通过全息表面实现精确、可预测的交互。
   * 如果只需要修饰的更改，则它可能足以使顶点法线平滑，而不会改变顶点位置。

* **平面查找**
   * 应用程序可能希望在空间映射提供的图面上执行多种形式的分析。
   * 一个简单的示例是 "平面查找";标识图面上的边界、大多数平面区域。
   * 平面区域可用作全息的工作图面，其中全息内容可由应用程序自动放置。
   * 平面区域可以限制用户界面，指导用户与最适合其需求的图面进行交互。
   * 在现实世界中，可以将平面区域用作可用于功能对象（如液晶屏、表格或白板）的全息物。
   * 平面区域可以定义播放区域，形成 videogame 级别的基础。
   * 平面区域可以帮助虚拟代理浏览现实世界，方法是确定真实人员可能会走到的地面区域。

## <a name="prototyping-and-debugging"></a>原型制作和调试

### <a name="useful-tools"></a>有用工具
* [HoloLens 模拟器](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md)可用于使用空间映射开发应用程序，而无需访问物理 HoloLens。 它可让你在真实环境中模拟 HoloLens 上的实时会话，并且应用程序通常会使用的所有数据，包括 HoloLens 运动、空间坐标系统和空间映射网格。 这可用于提供可靠的可重复输入，这对于调试问题和评估代码更改很有用。
* 若要重现方案，请从实时 HoloLens 捕获网络上的空间映射数据，然后将其保存到磁盘，并在后续调试会话中重复使用。
* [Windows 设备门户三维视图](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view)提供了一种方法，用于查看当前通过空间映射系统提供的所有空间图面。 这为应用程序内的空间曲面提供了比较基础;例如，您可以轻松判断是否有任何空间图面丢失或是否显示在错误的位置。

### <a name="general-prototyping-guidance"></a>一般原型设计指南
* 由于空间映射数据中的 [错误](spatial-mapping.md#what-influences-spatial-mapping-quality) 可能会对用户体验造成很大的影响，因此建议在各种环境中测试应用程序。
* 不要以始终在同一位置（例如在办公桌）上进行测试的习惯进行捕获。 请确保在不同位置、形状、大小和材料的各种曲面上进行测试。
* 同样，尽管综合数据或记录的数据对于调试非常有用，但不太依赖于相同的几个测试用例。 这可能会延迟查找更多测试会提前捕获的重要问题。
* 使用实际 (和理想的夺得) 用户进行测试是一个不错的做法，因为它们不能使用 HoloLens 或您的应用程序，这与使用的方式完全相同。 事实上，这可能会让您感到他人的行为、知识和假设是多么的呢？

## <a name="troubleshooting"></a>疑难解答
* 为了使 surface 网格正确面向，每个 GameObject 都需要处于活动状态，然后才能将其发送到 SurfaceObserver 来构造其网格。 否则，网格将显示在您的空间中，但会旋转为古怪度。
* 需要将运行与 SurfaceObserver 通信的脚本的 GameObject 设置为源。 否则，你创建并发送到 SurfaceObserver 的所有 Gameobject 都具有与父游戏对象的偏移量相等的偏移量。 这会使你的网格显示多个计量仪，这使得调试正在进行的操作非常困难。

## <a name="see-also"></a>另请参阅
* [坐标系统](coordinate-systems.md)
* [DirectX 中的空间映射](../develop/native/spatial-mapping-in-directx.md)
* [Unity 中的空间映射](../develop/unity/spatial-mapping-in-unity.md)
* [场景理解](scene-understanding.md)
* [房间扫描可视化](room-scan-visualization.md)
* [空间音效设计](spatial-sound-design.md)
* [案例研究 - 看透现实中的洞](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)
