---
title: 空间映射
description: 空间映射提供了在 HoloLens 环境中实际表面的详细表示。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射，HoloLens，混合现实，表面重建，网格，混合现实耳机，windows mixed reality 耳机，虚拟现实耳机，HoloLens，MRTK，混合现实工具包，场景理解，世界网格，封闭，物理学，导航，表面观察器，渲染，网格处理
ms.openlocfilehash: 941e72b441771849e48e8ebc4924605750804831
ms.sourcegitcommit: c0ba7d7bb57bb5dda65ee9019229b68c2ee7c267
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2021
ms.locfileid: "110143728"
---
# <a name="spatial-mapping"></a>空间映射

空间映射提供了针对 HoloLens 环境中实际表面表面的详细表示，使开发人员能够创建一个具有说服力混合的现实体验。 通过将现实世界与虚拟世界合并，应用程序可以使全息影像看起来非常真实。 应用程序通过提供熟悉的实际行为和交互，还可以更自然地与用户的预期保持一致。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a>设备支持

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><strong>功能</strong></td>
        <td><a href="/hololens/hololens1-hardware"><strong>HoloLens（第 1 代）</strong></a></td>
        <td><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></td>
        <td><a href="../discover/immersive-headset-hardware-details.md"><strong>沉浸式头戴显示设备</strong></a></td>
    </tr>
     <tr>
        <td>空间映射</td>
        <td>✔️</td>
        <td>✔️</td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a>为什么空间映射很重要？

利用空间映射，可以将对象放置在真实的图面上。 这有助于在用户世界定位对象，并利用真实的深度提示。基于其他全息影像和现实世界对象 Occluding 全息影像有助于说服用户这些全息影像实际位于其空间中。 在空间中浮动或随用户移动的全息影像并不是真的。 如果可能，可轻松放置项目。

放置或移动全息影像时显示表面 (使用投影网格) 。 这可以帮助用户了解他们最能最好地放置全息影像，并显示他们尝试放置全息影像的点是否未映射。 如果用户的角度太多，您可以向用户 "布告栏项目"。

## <a name="conceptual-overview"></a>概念概述

![覆盖房间的网格面](images/SurfaceReconstruction.jpg)<br>
*覆盖房间的空间映射网格示例*

用于空间映射的两个主要对象类型为 "空间图观察器" 和 "空间图面"。

应用程序为空间图面观察器提供一个或多个边界卷，以定义应用程序希望接收空间映射数据的空间区域。 对于其中每个卷，空间映射将为应用程序提供一组空间图面。

这些卷 (基于实际) 固定位置中的固定位置，或者它们可能会附加到 HoloLens (它们在 HoloLens 经过环境) 时移动但不旋转。 每个空间图面描述了少量空间中的实际表面，这些表面表示为附加到世界锁定空间坐标系 的三角形 [网格](coordinate-systems.md)。

当 HoloLens 收集有关环境的新数据时，当环境发生更改时，空间图面将出现、消失和更改。

## <a name="spatial-awareness-design-concepts-demo"></a>空间感知设计概念演示

若要了解空间感知设计概念的运行情况，请查看下面的设计 [全息影像 - 空间感知]() 视频演示。 完成后，请继续详细了解特定主题。

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Microsofts-Designing-Holograms-Spatial-Awareness-Chapter/player]

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a>空间映射与场景理解 WorldMesh

对于HoloLens 2，可以查询静态版本的空间映射数据，使用场景理解 [SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 设置) 。 下面是访问空间映射数据的两种方法之间的差异：
* 空间映射 API：
   * 有限范围：空间映射数据可用于用户周围缓存的"气泡"大小有限的应用程序。
   * 通过 SurfacesChanged 事件提供更改的网格区域的低延迟更新。
   * 由"每三角形一个三角形"参数控制的详细信息的可变级别。
* 场景理解 SDK：
   * 无限制范围 - 提供查询半径内所有扫描的空间映射数据。
   * 提供空间映射数据的静态快照。 获取更新的空间映射数据需要针对整个网格运行新查询。
   * RequestedMeshLevelOfDetail 设置控制的详细信息的一致级别。

## <a name="what-influences-spatial-mapping-quality"></a>哪些因素会影响空间映射质量？

[此处](/hololens/hololens-environment-considerations)详细介绍的几个因素可能会影响这些错误的频率和严重性。  但是，你应设计应用程序，以便即使在空间映射数据中存在错误时，用户也可以实现其目标。

## <a name="common-usage-scenarios"></a>常见使用方案

![常见空间映射使用方案的插图：放置、封闭、物理学和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空间映射为应用程序提供了向用户提供自然和熟悉的交互形式的机会。比将您的手机放在办公桌上的情况如何？

 (或更常见地限制全息影像的位置，) 的任何空间位置选择都是在表面上，从空间) 的 3D (点到图面 (上的 2D) 点的自然映射。 这会减少用户提供给应用程序所需的信息量，并使用户的交互速度更快、更简单且更精确。 这是正确的，因为 "距离远离" 不是我们用于与其他人或计算机进行物理通信的东西。 当我们使用手指点时，我们指定的是一个方向，而不是距离。

下面是一个重要的注意事项：当应用程序从方向推断距离时 (例如，通过沿用户的注视方向 raycast 来查找最接近的空间图面) ，这必须生成用户可以可靠地预知的结果。 否则，用户将失去控制，这很快就会变得沮丧。 有助于实现此目的的一种方法是执行多个 raycasts，而不只是一个。 聚合结果应更平滑且更具可预测性，不会受到暂时性的 "离群" 结果的影响 (因为这可能是由于光线通过小孔而导致的，或者是用户不知道) 的小位几何导致的。 还可以在一段时间内执行聚合或平滑处理;例如，可以限制与用户之间的间距变化的最大速度。 仅限制最小和最大距离值也有所帮助，因此移动的全息影像不会突然离开距离或崩溃回到用户的面部。

应用程序还可使用表面的形状和方向来引导全息影像放置。 全息大把不应穿过墙，并且应该与楼层一起刷新，即使它有点不均匀。 此类功能可能依赖于物理碰撞的使用，而不是光线广播，但类似的关注点将适用。 如果放置的全息影像具有许多小多边形（例如，在长脚上贴边）时，将这些多边形的物理表示形式扩展到更宽、更平滑的多边形，以便它们更能够在空间图面上滑动，而无需进行滑动。

在极端情况下，可以完全简化用户输入，空间图面可用于完全自动放置全息影像。 例如，应用程序可以在墙的某一位置放置全息光开关，供用户按下。 可预测性的相同注意事项在此处同时适用;如果用户希望控制全息影像的放置，但应用程序并不总是将全息影像放在预期的位置 (如果光开关出现在用户无法到达) 的位置，则这是一种令人沮丧的体验。 执行需要某些时间进行用户更正的自动放置实际上比仅要求用户始终自行进行放置要差;因为预期自动放置 *会成功*，所以手动更正就像一个负担！

另请注意，应用程序使用空间图面进行放置的能力在很大程度上取决于应用程序的扫描 [体验](spatial-mapping.md#the-environment-scanning-experience)。 如果尚未扫描图面，则不能用于放置。 由应用程序向用户表明这一点，以便他们可以帮助扫描新表面或选择新位置。

在放置过程中，对用户的视觉反馈非常重要。 用户需要知道全息图基于具有 [接地效果](spatial-mapping.md#visualization)的最近图面。 它们应了解为什么会对全息图的移动进行约束 (例如，因为与附近的另一个曲面) 发生冲突。 如果他们无法在当前位置放置全息影像，则视觉对象反馈应清楚地说明为什么不这样做。 例如，如果用户尝试将全息的沙发卡在墙壁上，则墙后的沙发部分应 pulsate 为生气的颜色，。 相反，如果应用程序在用户可以看到真实表面的位置找不到空间图面，则应用程序应使其清晰。 此区域中明显不会产生接地效果的情况。

### <a name="occlusion"></a>封闭

空间映射图面的主要用途之一就是遮蔽全息影像。 这一简单的行为对全息影像的明显影响非常大，有助于创建 visceral 的意义，真正与用户 inhabits 相同的物理空间。

封闭还向用户提供信息;当现实世界图面上出现全息图时，这就为世界上该全息图的空间位置提供了额外的视觉反馈。 相反，封闭也可以有用 *隐藏* 用户的信息;occluding 的后台影像可以以直观的方式减少视觉干扰。 若要隐藏或显示全息图，用户只需移动其头。

封闭还可用于根据熟悉的物理交互，为自然用户界面提供合理的预期。如果某个图面的封闭像素是一个全息图，就是因为该表面是稳定的，因此用户应该认为，全息图将与该表面发生 *冲突* ，而不会通过它。

有时，不需要封闭的全息影像。 如果用户需要与全息影像交互，则需要查看它，即使它位于真实表面后面。 在这种情况下，在遮挡此类全息影像时，以不同方式呈现 (例如，降低其亮度) 。 这样，用户就可以直观地找到全息影像，但他们仍然知道它位于某一位置后面。

### <a name="physics"></a>物理

使用物理模拟是空间映射的另一种方式，可用于强化用户物理空间中全息影像的存在。  当我的全息球从我的台子上真实地滚出时，在楼层中弹跳并消失在树下时，我可能很难认为它不存在。

物理模拟还为应用程序提供了使用自然和熟悉的基于物理的交互的机会。 如果用户在楼层四处移动一块全息影像，用户可能会更轻松地响应，就像它通过适当的惯性和摩擦在楼层上滑动一样。

若要生成真实的物理行为，可能需要执行一些网格处理，例如[](spatial-mapping.md#mesh-processing)填充孔、移除浮动的形像和平滑粗糙表面。

还需要考虑应用程序的扫描体验 [如何影响其物理](spatial-mapping.md#the-environment-scanning-experience) 模拟。 首先，缺失的图面不会与任何内容冲突;当滚球从已知世界末尾向下滚下时会发生什么情况？ 其次，需要决定是否继续响应环境中一段时间的变化。 在某些情况下，需要尽快做出响应;假设用户使用门和建筑作为可移动门架，以防御传入的拉丁语箭头的风暴。 但是，在其他情况下，你可能想要忽略新更新;如果狗决定坐在轨道中间，那么在楼层的自行车道周围驾驶全息运动汽车可能突然变得不是那么有趣。

### <a name="navigation"></a>导航

应用程序可以使用空间映射数据 (或代理授予全息字符，) 能够以真实人员的相同方式浏览现实。 这可以通过将其限制为用户及其好友的一组自然、熟悉的行为来帮助强化是否存在全息字符。

导航功能对于用户也很有用。 在给定区域中生成导航地图后，可以将其共享，为不熟悉该位置的新用户提供全息说明。 此映射可用于帮助保持行人的流量顺畅地流动，或避免在危险位置（如构造站点）中发生意外。

实现导航功能所涉及的关键技术挑战将会对不可的表面进行可靠检测， (人们不会对表进行检查！ ) 并正常地适应环境中的变化 (人类不会遍历关闭的门！ ) 。 网格可能需要进行一些 [处理](spatial-mapping.md#mesh-processing) 才能用于通过虚拟字符进行路径规划和导航。 平滑网格和删除 hallucinations 可帮助避免字符停滞。 你可能还希望大幅简化网格，提高字符的路径规划和导航计算速度。 在开发视频游戏技术时，这些挑战已经得到了很大的关注，其中提供了大量有关这些主题的信息。

Unity 中的内置 NavMesh 功能不能与空间映射图面一起使用。 这是因为在应用程序启动之前空间映射图面是未知的，但需要提前从源资产生成 NavMesh 数据文件。 另请注意，空间映射系统不会提供与用户当前位置 [有关的有关表面的信息](spatial-mapping.md#the-environment-scanning-experience) 。 因此，如果要构建大区域的地图，应用程序必须 "记住" 自身。

### <a name="visualization"></a>可视化效果

大多数情况下，空间图面是可见的;以最大程度地减少视觉混乱，让现实世界代表自己。 但是，有时直接可视化空间映射图面很有用，尽管它们的实际对应图面可见。

例如，当用户尝试将全息影像放置到图面上时 (将全息箱放在墙上（例如) 将阴影投射到图面上来"地面"全息影像会很有用。 这样，用户就更清楚地了解全息影像和表面之间的完全物理邻近性。 这也是在用户提交更改之前直观地"预览"更改的更一般做法示例。

通过可视化图面，应用程序可以与用户共享其环境理解。 例如，全息棋盘游戏可以可视化它标识为"表"的水平图面，以便用户知道他们应在何处进行交互。

可视化图面是向用户显示隐藏在视图中的附近空间的一种有用方法。 这可以提供一种方法，让用户能够访问其 (及其包含的所有全息影像) 来自其房间。

空间映射提供的表面网格可能并不特别"干净"。 正确可视化它们非常重要。 传统的照明计算可能会以视觉上分散注意力的方式突出显示表面法线中的错误，而投射到图面上的"干净"纹理可能有助于赋予其更简洁的外观。 在呈现图面之前，还可以[](spatial-mapping.md#mesh-processing)执行网格处理以改进网格属性。

> [!NOTE]
> HoloLens 2实现新的场景理解运行时 [，它为](scene-understanding.md)混合现实开发人员提供了结构化的高级别环境表示形式，旨在简化放置、遮挡、物理和导航的实现。

## <a name="using-the-surface-observer"></a>使用 Surface Observer

空间映射的起点是表面观察器。 程序流如下所示：
* 创建 surface 观察器对象
   * 提供一个或多个空间卷，以定义应用程序希望接收空间映射数据的感兴趣的区域。 空间量只是定义空间区域的形状，例如球或 box。
   * 使用带有世界锁定的空间坐标系统的空间量来识别物理世界的固定区域。
   * 使用空间量，使用正文锁定的空间坐标系统更新每个帧，以标识移动 (但不会向用户旋转) 的空间区域。
   * 以后可以随时更改这些空间卷，因为应用程序或用户的状态会发生更改。
* 使用轮询或通知来检索有关空间图面的信息
   * 您可以随时 "轮询" 面观察器来实现空间图面状态。 相反，你可以注册 surface 观察器的 "表面变化" 事件，这将在空间图面改变时通知应用程序。
   * 对于动态空间量（如视图截锥或正文锁定卷），应用程序需要通过设置感兴趣的区域，然后获取当前的空间图面集来轮询每个帧的更改。
   * 对于静态卷（如涵盖单个房间的全球锁定的多维数据集），应用程序可能会注册 "已更改" 事件，以便在该卷内的空间表面发生变化时得到通知。
* 处理表面更改
   * 循环访问提供的空间图面集。
   * 按添加、更改或删除的方式对空间图面进行分类。
   * 对于每个已添加或已更改的空间图面，如果适当，请提交一个异步请求，以在所需的详细信息级别接收表示该图面的当前状态的已更新网格。
* )  (以下部分中的详细信息，处理异步网格请求。

## <a name="mesh-caching"></a>网格缓存

空间图面由密集三角形网格表示。 存储、呈现和处理这些网格可能会占用大量计算和存储资源。 因此，每个应用程序都应采用适合其需求的网格缓存方案，以最大程度地减少用于网格处理和存储的资源。 此方案应确定要保留的网格以及要丢弃的网格，以及何时更新每个空间图面的网格。

其中讨论的许多注意事项将直接告知应用程序应如何处理网格缓存。 应考虑用户如何在环境中移动（需要哪种表面、何时观察不同的表面以及何时应捕获环境中的更改）。

解释图面观察器提供的"surfaces changed"事件时，基本网格缓存逻辑如下所示：
* 如果应用程序看到以前未看到的空间图面 ID，则它应认为这是一个新的空间图面。
* 如果应用程序看到具有已知 ID 但具有新更新时间的空间图面，则它应视为已更新的空间图面。
* 如果应用程序不再看到具有已知 ID 的空间图面，则它应将其视为已删除的空间图面。

然后，由每个应用程序做出以下选择：
* 对于新的空间图面，应请求网格吗？
   * 通常，应该立即为新的空间图面请求网格，这可能为用户提供有用的新信息。
   * 但是，应优先处理用户前后的新空间图面，并首先请求其网格。
   * 如果不需要新网格，例如，如果应用程序已永久或暂时"冻结"其环境模型，则不应请求它。
* 对于更新的空间图面，应请求网格吗？
   * 应优先处理用户前后更新的空间图面，并首先请求其网格。
   * 新图面的优先级可能高于更新后的图面，尤其是在扫描体验期间。
   * 为了限制处理成本，应用程序可能希望限制它们处理空间图面更新的速率。
   * 可以推断出对空间图面所做的更改很小，例如，如果图面的边界很小，则更新可能不太重要，无法处理。
   * 对于用户感兴趣的当前区域之外的空间表面的更新，可能会完全忽略，但是在这种情况下，修改 surface 观察器使用的空间边界卷可能更有效。
* 对于删除的空间表面，是否应丢弃网格？
   * 通常应为删除的空间图面立即丢弃网格，使全息图封闭保持正确。
   * 但是，如果应用程序有理由相信某个空间图面很快就会重新出现 (基于用户体验) 的设计，则保留该网格比丢弃其网格并稍后重新创建它可能更有效。
   * 如果应用程序正在生成用户环境的大规模模型，则可能根本不想丢弃任何网格。 不过，它仍需要限制资源使用情况，可能通过将网格后台打印到磁盘，因为空间图面消失。
   * 在空间表面生成过程中，某些相对罕见的事件可能会导致空间图面替换为类似位置但 Id 不同的新空间图面。 因此，选择不放弃已移除表面的应用程序应注意不会有多个高度重叠的空间表面，网格覆盖同一位置。
* 是否应为任何其他空间图面丢弃网格？
   * 即使存在空间图面，如果它对用户体验不再有用，则应将其丢弃。 例如，如果应用程序 "将门口的另一侧的空间替换为备用虚拟空间，则该房间中的空间表面将不再重要。

下面是使用空间和时态滞后的示例网状缓存策略：
* 请考虑一个应用程序，该应用程序希望使用用户四处查看和四处移动时跟随用户凝视的 frustum 形空间音量。
* 空间图面可能会暂时从此卷中消失，因为用户离开该图面或离它更远一点...仅回顾一下，或稍后再进一步。 在这种情况下，放弃和重新创建此图面的网格表示许多冗余处理。
* 为了减少处理的更改数，应用程序使用两个空间图面观察程序，一个包含在另一个空间图面观察程序内。 较大的卷是球面的，并跟随用户"延迟";它仅在需要时移动，以确保其中心在用户 2.0 米范围内。
* 新的和更新的空间图面网格始终从较小的内部表面观察程序进行处理，但网格会进行缓存，直到它们从较大的外部表面观察程序消失。 这样，应用程序可以避免由于本地用户移动而处理许多冗余更改。
* 由于空间图面也可能因跟踪丢失而暂时消失，因此应用程序还会在跟踪丢失期间延迟丢弃已删除的空间图面。
* 通常，应用程序应评估更新处理减少与内存使用量增加之间的权衡，以确定其理想的缓存策略。

## <a name="rendering"></a>渲染

空间映射网格倾向于使用三种主要方式进行呈现：
* 对于图面可视化
   * 直接可视化空间图面通常很有用。 例如，将对象中的"阴影"强制转换到空间图面上，可以在用户将全息影像放置在图面上时为用户提供有用的视觉反馈。
   * 请记住，空间网格不同于 3D 艺术家可能创建的网格类型。 三角形拓扑不会像人工创建的拓扑一样"干净"，网格将遭受 [各种错误](spatial-mapping.md#what-influences-spatial-mapping-quality)。
   * 若要创建令人满意的视觉对象美观，可能需要进行一些 [网格处理](spatial-mapping.md#mesh-processing)，例如填充孔或平滑曲面法。 您还可能希望使用着色器将艺术家设计的纹理投影到网格上，而不是直接可视化网格拓扑和法线。
* 对于真实的图面后面的 occluding 全息影像
   * 空间图面可以在仅深度传递中呈现，这只会影响 [深度缓冲区](/windows/win32/direct3d9/depth-buffers) 并且不会影响颜色呈现器目标。
   * 这 primes 了深度缓冲区，遮蔽随后在空间图面后面呈现全息影像。 最准确的全息影像封闭增强了全息影像在用户的物理空间内确实存在的意义。
   * 若要启用仅深度渲染，请更新混合状态，将所有颜色渲染目标的 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 设置为零。
* 用于修改真实环境中全息图封闭像素的外观
   * 当封闭像素时，通常会隐藏呈现的几何图形。 这是通过将 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 中的深度函数设置为 "小于或等于" 来实现的，这会使几何仅在 **离相机更近** 的位置（而不是所有先前呈现的几何）可见。
   * 但是，在某些情况下，即使在封闭像素时也能看到某些几何，并在封闭像素作为向用户提供视觉反馈时修改其外观。 例如，这允许应用程序向用户显示对象的位置，同时使其清楚地显示在实际表面。
   * 若要实现此目的，请使用另一个创建所需 "封闭像素" 外观的着色器第二次渲染几何。 在第二次渲染几何之前，对 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)进行两次更改。 首先，将 "深度函数" 设置为 "大于或等于"，以便仅在 **其从相机中看到** 的位置比之前呈现的所有几何都可见。 其次，将 DepthWriteMask 设置为零，以便深度缓冲区不会修改 (因为深度缓冲区应继续表示离相机区域最近的几何图形) 。 

[呈现](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) 空间映射网格时，性能是一个重要的问题。 下面是一些特定于呈现空间映射网格的呈现性能技术：
* 调整三角形密度
   * 从表面观察器请求空间图面网格时，请请求满足你需求的三角形网格的最低密度。
   * 根据表面与用户的距离及其与用户体验的相关性，按表面改变三角形密度可能很有意义。
   * 减少三角形计数会降低 GPU 上的内存使用量和顶点处理成本，但不会影响像素处理成本。
* 使用 frustum 剔除
   * Frustum 剔除会跳过无法看到的绘图对象，因为它们位于当前显示图面之外。 这降低了 CPU 和 GPU 处理成本。
   * 由于基于每个网格执行剔除，并且空间图面可能很大，因此将每个空间图面网格分解为较小的区块可能会导致更高效的剔除 (因为屏幕外三角形呈现) 。 但是，有一个权衡;网格数越多，必须进行绘制调用就更多，这会增加 CPU 成本。 在极端情况下，frustum 剔除计算本身甚至可以具有可度量的 CPU 成本。
* 调整呈现顺序
   * 空间图面往往很大，因为它们表示用户周围的整个环境。 GPU 上的像素处理成本可能很高，尤其是在存在多个可见几何图形层的情况下 (包括空间图和其他全息影像) 。 在这种情况下，离用户最近的层会进一步遮挡任何层，因此呈现这些较远的层所花费的任何 GPU 时间都将浪费。
   * 若要减少 GPU 上的这一冗余工作，这有助于在最接近的情况下，以从上到下的顺序呈现不透明的图面， (上一次) 。 "不透明" 是指在您的 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)中将 DepthWriteMask 设置为一个的表面。 当呈现最近的图面时，它们将为深度缓冲区的质数，以便 GPU 上的像素处理器能够有效地跳过更远的图面。

## <a name="mesh-processing"></a>网格处理

应用程序可能希望对空间 surface 网格执行 [各种操作](spatial-mapping.md#mesh-processing) 以满足其需求。 每个空间 surface 网格提供的索引和顶点数据与用于在所有新式渲染 Api 中呈现三角形网格的 [顶点和索引缓冲区](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 使用的布局相同。 不过，有一个关键事实需要注意的是，空间映射三角形具有 **前后的缠绕顺序**。 每个三角形都用网格的索引缓冲区中的三个顶点索引表示，当从 **正面** 查看三角形时，这些索引会按 **顺时针** 顺序标识三角形的顶点。 空间 surface 网格的正面 (或外部) 与您预期在实际表面的正面 () 可见。

如果 surface 观察器提供的益处三角形密度仍不足粗，则应用程序应仅执行网格简化，这种工作的计算成本非常高，且已由运行时执行以生成各种提供的详细信息级别。

由于每个 surface 观察器都可以提供多个未连接的空间图面，因此某些应用程序可能希望彼此剪裁这些空间 surface 网格，然后将它们 zipper 在一起。 通常，剪裁步骤是必需的，因为附近的空间 surface 网格通常会稍微重叠。

## <a name="raycasting-and-collision"></a>Raycasting 和冲突

为了使物理 API (例如 [Havok](https://www.havok.com/)) 为应用程序提供空间图面的光线广播和碰撞功能，应用程序必须为物理 API 提供空间表面网格。 用于物理的网格通常具有以下属性：
* 它们仅包含少量三角形。 物理运算比渲染操作的计算密集型更多。
* 它们"水很紧"。 旨在为实心的图面中不应有小孔;即使小到不可见的孔也可能会导致问题。
* 它们被转换为凸包。 凸包具有很少的多边形且没有孔，并且其处理计算效率比原始三角形网格要高效得多。

对空间图面进行光线广播时，请记住，这些表面通常是复杂、杂乱的形状，包含杂乱的小细节 -就像桌面一样！ 这意味着，单个光线广播通常不足以提供有关表面形状及其附近空白空间形状的足够信息。 通常，建议在一个小区域中执行多个光线广播，并使用聚合结果获得对表面更可靠的理解。 例如，使用平均 10 个光线广播来引导全息影像在表面上放置，将生成一种更平滑且不太"抖动"的结果，因为只需使用一个光线广播。

但是，请记住，每个光线广播的计算成本可能很高。 根据你的使用方案，应该将每个帧 () 完成的额外光线广播的计算成本与网格处理的计算成本进行平衡，以在空间网格更新) [](spatial-mapping.md#mesh-processing)时平滑和移除空间 (中的孔。

## <a name="the-environment-scanning-experience"></a>环境扫描体验

使用空间映射的每个应用程序都应考虑提供"扫描体验";应用程序引导用户扫描应用程序正常运行所需的表面的过程。

![扫描示例](images/sr-mixedworld-140429-8pm-00068-1000px.png)<br>
*扫描示例*

此扫描体验的性质可能会因每个应用程序的需求而异，但两个主要原则应指导其设计。

首先， **主要关注与用户之间的明确通信**。 用户应始终了解是否满足应用程序的要求。 如果它们未得到满足，用户应立即清楚地了解这样做的原因，并且应快速引导他们采取相应的操作。

其次， **应用程序应尝试在效率和可靠性之间取得平衡**。 如果可以可靠地这样做 **，** 应用程序应自动分析空间映射数据以节省用户时间。 当无法可靠地这样做时，应用程序应使用户能够快速向应用程序提供所需的附加信息。

为了帮助设计正确的扫描体验，请考虑以下哪种可能性适用于应用程序：

* **无扫描体验**
   * 应用程序无需任何引导式扫描体验即可完美运行;它将了解在自然用户移动过程中观察到的图面。
   * 例如，允许用户使用全息喷射油漆在表面上绘制的应用程序只需要了解用户当前可见的表面。
   * 如果用户已使用 HoloLens 花费了大量时间，则环境可能已经过扫描。
   * 但请记住，空间映射使用的相机只能看到用户前面的 3.1 米，因此空间映射将不知道任何较远的图面，除非用户过去从更近的距离观察到了这些表面。
   * 因此，用户了解扫描了哪些表面，应用程序应提供对此效果的视觉反馈，例如，将虚拟阴影投射到扫描的图面上可帮助用户将全息影像放在这些图面上。
   * 对于这种情况，应将空间图面观察器的边界卷更新为主体锁定的 [空间坐标系统](coordinate-systems.md)，使其跟随用户。

* **查找合适的位置**
   * 应用程序可设计为在具有特定要求的位置使用。
   * 例如，应用程序可能需要用户附近的空白区域，以便他们能够安全地练习全息 kung-fu。
   * 应用程序应提前向用户传达任何特定要求，并通过清晰的视觉反馈来强化。
   * 在此示例中，应用程序应可视化所需空区域的范围，并以可视方式突出显示此区域内任何不需要的对象的状态。
   * 对于这种情况，空间图面观察器的边界卷应在所选位置使用世界锁定的 [空间坐标系统](coordinate-systems.md) 。

* **查找图面的合适配置**
   * 应用程序可能需要特定的图面配置，例如两个大型、平整、相反的壁，以创建全息的镜像厅。
   * 在这种情况下，应用程序需要对空间映射提供的图面进行分析以检测适当的图面，并将用户定向到它们。
   * 如果应用程序的表面分析不可靠，用户应具有回退选项。 例如，如果应用程序错误地将门口标识为平整壁，则用户需要一种简单的方法来更正此错误。

* **扫描部分环境**
   * 应用程序可能希望只捕获用户所指示的部分环境。
   * 例如，应用程序会扫描房间的某个部分，以使用户可以为想要销售的家具发布全息保密广告。
   * 在这种情况下，应用程序应该捕获用户在扫描期间观察到的区域内的空间映射数据。

* **扫描整个聊天室**
   * 应用程序可能需要扫描当前房间中的所有表面，包括用户之后的所有表面。
   * 例如，游戏可能会将用户置于 Gulliver 的角色下，而来自数百位小 Lilliputians 从四面八方接近。
   * 在这种情况下，应用程序需要确定当前房间中已扫描的图面数，并引导用户凝视以填充明显的间隙。
   * 此过程的关键是提供视觉反馈，让用户清楚地了解尚未扫描的图面。 例如，应用程序可以使用基于距离 [的](/windows/win32/direct3d9/fog-formulas) 遮盖来直观地突出显示空间映射图面未覆盖的区域。

* **创建环境的初始快照**
   * 应用程序可能需要在拍摄初始"快照"后忽略环境中的所有更改。
   * 这可能适合避免中断用户创建的数据，这些数据与环境的初始状态紧密耦合。
   * 在这种情况下，扫描完成后，应用程序应在其初始状态创建空间映射数据的副本。
   * 如果全息影像仍被环境正确遮挡，应用程序应继续接收空间映射数据更新。
   * 对空间映射数据的持续更新还允许可视化发生的任何更改，向用户阐明环境以前和现在状态之间的差异。

* **获取用户启动的环境快照**
   * 应用程序可能只希望在用户指示时响应环境更改。
   * 例如，用户可以在不同的时刻捕获朋友的姿势，从而创建一个朋友的多个 3D"小马"。

* **允许用户更改环境**
   * 应用程序可以设计为实时响应用户环境中的任何更改。
   * 例如，绘制一个墙的用户可以为另一端进行全息播放触发"场景更改"。

* **指导用户避免空间映射数据中的错误**
   * 应用程序在扫描其环境时，可能希望向用户提供指导。
   * 这可以帮助用户避免 [空间映射数据中](spatial-mapping.md#what-influences-spatial-mapping-quality)出现某些类型的错误，例如，远离 sunlit windows 或镜像。

需要注意的一个额外细节是，空间映射数据的 "范围" 不受限制。 虽然空间映射确实生成了大量空间的永久数据库，但它只会使该数据可用于用户周围大小限制较小的应用程序。 如果从较长的 corridor 开始开始，并从一开始就开始走出足够的距离，最终空间表面会消失。 在应用程序从可用空间映射数据中消失后，可以通过在应用程序中缓存这些图面来缓解这种情况。

## <a name="mesh-processing"></a>网格处理

它可能有助于检测图面中的常见错误类型，并根据需要对空间映射数据进行筛选、删除或修改。

请记住，空间映射数据应尽可能忠实到实际的表面，因此，任何正在进行的处理都将进一步从 "真实" 改变你的曲面。

下面是一些可能有用的不同类型网格处理的示例：

* **孔洞填充**
   * 如果导致暗材料的小对象无法扫描，它将在周围表面上留下一个孔。
   * 孔洞会影响封闭：在被视为不透明的实际表面，可以通过 "通过" 洞来查看全息影像。
   * 孔洞会影响 raycasts：如果使用 raycasts 帮助用户与表面交互，则这些光线可能不需要通过洞。 一种缓解措施是使用多个 raycasts 的捆绑，涵盖适当大小的区域。 这将允许你筛选 "离群离群" 结果，这样即使一个 raycast 通过一个小孔，聚合结果仍将有效。 但是，这种方法会产生计算成本。
   * 孔会影响物理碰撞：由物理模拟控制的对象可能会从地中的孔中下降并丢失。
   * 可以以算法方式在表面网格中填充此类孔。 但是，需要优化算法，以便不填充"实际孔"（如窗口和门道）。 很难可靠地区分"实孔"和"虚孔"，因此，需要使用不同的启发式方法（如"大小"和"边界形状"）进行试验。

* **删除会场**
   * 反射、亮光和移动对象可能会让小延迟的"幻音"在中空浮动。
   * 全息影像会影响遮挡：当深色形状在其他全息影像前面移动并遮挡时，会变为可见。
   * 反射会影响光线广播：如果使用光线广播来帮助用户与表面交互，则这些射线可能会命中幻化，而不是其后面的表面。 与孔一样，一种缓解措施是使用许多光线广播而不是单个光线广播，但这同样会花费计算成本。
   * 光相影响物理冲突：由物理模拟控制的对象可能会停滞在幻化中，无法通过看似清晰的空间区域移动。
   * 从表面网格中筛选此类形像是有可能的。 但是，与孔一样，你需要优化算法，以便不会删除真正的小对象，如灯架和门控点。

* **平滑**
   * 与实际相对应图相比，空间映射可能会返回看起来粗糙或"干扰"的图面。
   * 平滑度会影响物理碰撞：如果地面粗糙，物理模拟的球可能无法在直线上平滑滚动。
   * 平滑度会影响呈现：如果直接可视化图面，粗糙表面法线可能会影响其外观并破坏"干净"外观。 可以通过在着色器中使用用于呈现表面的适当照明和纹理来缓解这种情况。
   * 可以在 surface 网格中平滑粗糙度。 但是，这可能会使表面远离相应的实际表面。 维护近函件对于生成准确的全息图封闭非常重要，并使用户能够通过全息表面实现精确、可预测的交互。
   * 如果只需要修饰的更改，则它可能足以使顶点法线平滑，而不会改变顶点位置。

* **平面查找**
   * 应用程序可能希望在空间映射提供的图面上执行多种形式的分析。
   * 一个简单的示例是 "平面查找";确定边界，大多数平面区域。
   * 平面区域可用作全息的工作图面，其中全息内容可由应用程序自动放置。
   * 平面区域可以限制用户界面，指导用户与最适合其需求的图面进行交互。
   * 在现实世界中，可以将平面区域用作可用于功能对象（如液晶屏、表格或白板）的全息物。
   * 平面区域可以定义播放区域，形成视频游戏级别的基础。
   * 平面区域可以帮助虚拟代理浏览现实世界，方法是确定真实人员可能会走到的地面区域。

## <a name="prototyping-and-debugging"></a>原型制作和调试

### <a name="useful-tools"></a>有用工具

* [HoloLens 模拟器](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md)可用于使用空间映射开发应用程序，而无需访问物理 HoloLens。 使用该功能，您可以在真实环境中使用您的应用程序通常会使用的所有数据（包括 HoloLens 运动、空间坐标系统和空间映射网格）来模拟 HoloLens 上的实时会话。 这可用于提供可靠的可重复输入，这对于调试问题和评估代码更改很有用。
* 若要重现方案，请从实时 HoloLens 捕获网络上的空间映射数据，然后将其保存到磁盘，并在以后的调试会话中重复使用。
* [Windows 设备门户 3D](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view)视图提供了一种通过空间映射系统查看当前可用的所有空间图面的方法。 这为应用程序中的空间图面提供了比较基础;例如，可以轻松判断任何空间图面是否缺失或是否显示在错误的位置。

### <a name="general-prototyping-guidance"></a>常规原型制作指南

* [由于](spatial-mapping.md#what-influences-spatial-mapping-quality)空间映射数据中的错误可能会严重影响用户体验，因此建议你在各种环境中测试应用程序。
* 请勿陷入始终在同一位置进行测试（例如，在服务台）这一习惯中。 确保在不同位置、形状、大小和材料的各种表面上进行测试。
* 同样，尽管合成或记录的数据可用于调试，但不要对相同的几个测试用例过于依赖。 这可能会延迟查找先前捕获到的更多不同测试的重要问题。
* 最好使用真实的 (和理想情况下未) 的用户执行测试，因为他们可能不会以与使用 HoloLens 或应用程序完全相同的方式使用 HoloLens 或应用程序。 事实上，你可能会意外地发现，人们的行为、知识和假设可能非常不同！

## <a name="troubleshooting"></a>疑难解答

* 为了使图面网格正确定位，每个 GameObject 在发送到 SurfaceObserver 之前都需要处于活动状态，才能构造其网格。 否则，网格会显示在空间中，但旋转角度不一样。
* 需要将运行与 SurfaceObserver 通信的脚本的 GameObject 设置为源。 否则，创建并发送到 SurfaceObserver 以构造其网格的所有 GameObject 都将具有与父游戏对象的偏移量相等的偏移量。 这会使网格显示数米远，从而难以调试所进行的工作。

## <a name="see-also"></a>另请参阅

* [坐标系统](coordinate-systems.md)
* [DirectX 中的空间映射](../develop/native/spatial-mapping-in-directx.md)
* [Unity 中的空间映射](../develop/unity/spatial-mapping-in-unity.md)
* [场景理解](scene-understanding.md)
* [房间扫描可视化](room-scan-visualization.md)
* [空间音效设计](spatial-sound-design.md)
* [案例研究 - 看透现实中的洞](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)