---
title: 空间映射
description: 空间映射提供了在 HoloLens 环境中实际表面的详细表示。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射，HoloLens，混合现实，表面重建，网格，混合现实耳机，windows mixed reality 耳机，虚拟现实耳机，HoloLens，MRTK，混合现实工具包，场景理解，世界网格，封闭，物理学，导航，表面观察器，渲染，网格处理
ms.openlocfilehash: 3268f25f86cdfea3aa1ae0b77c4fbeb9aa0ce1b9
ms.sourcegitcommit: 8f141a843bcfc57e1b18cc606292186b8ac72641
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2021
ms.locfileid: "110196422"
---
# <a name="spatial-mapping"></a><span data-ttu-id="77331-104">空间映射</span><span class="sxs-lookup"><span data-stu-id="77331-104">Spatial mapping</span></span>

<span data-ttu-id="77331-105">空间映射提供了针对 HoloLens 环境中实际表面表面的详细表示，使开发人员能够创建一个具有说服力混合的现实体验。</span><span class="sxs-lookup"><span data-stu-id="77331-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="77331-106">通过将现实世界与虚拟世界合并，应用程序可以使全息影像看起来非常真实。</span><span class="sxs-lookup"><span data-stu-id="77331-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="77331-107">应用程序通过提供熟悉的实际行为和交互，还可以更自然地与用户的预期保持一致。</span><span class="sxs-lookup"><span data-stu-id="77331-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-supports"></a><span data-ttu-id="77331-108">设备支持</span><span class="sxs-lookup"><span data-stu-id="77331-108">Device supports</span></span>

<table>
    <colgroup>
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    <col width="25%" />
    </colgroup>
    <tr>
        <td><span data-ttu-id="77331-109"><strong>功能</strong></span><span class="sxs-lookup"><span data-stu-id="77331-109"><strong>Feature</strong></span></span></td>
        <td><span data-ttu-id="77331-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens（第 1 代）</strong></a></span><span class="sxs-lookup"><span data-stu-id="77331-110"><a href="/hololens/hololens1-hardware"><strong>HoloLens (1st gen)</strong></a></span></span></td>
        <td><span data-ttu-id="77331-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span><span class="sxs-lookup"><span data-stu-id="77331-111"><a href="https://docs.microsoft.com/hololens/hololens2-hardware"><strong>HoloLens 2</strong></span></span></td>
        <td><span data-ttu-id="77331-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>沉浸式头戴显示设备</strong></a></span><span class="sxs-lookup"><span data-stu-id="77331-112"><a href="../discover/immersive-headset-hardware-details.md"><strong>Immersive headsets</strong></a></span></span></td>
    </tr>
     <tr>
        <td><span data-ttu-id="77331-113">空间映射</span><span class="sxs-lookup"><span data-stu-id="77331-113">Spatial mapping</span></span></td>
        <td><span data-ttu-id="77331-114">✔️</span><span class="sxs-lookup"><span data-stu-id="77331-114">✔️</span></span></td>
        <td><span data-ttu-id="77331-115">✔️</span><span class="sxs-lookup"><span data-stu-id="77331-115">✔️</span></span></td>
        <td>❌</td>
    </tr>
</table>


## <a name="why-is-spatial-mapping-important"></a><span data-ttu-id="77331-116">为什么空间映射很重要？</span><span class="sxs-lookup"><span data-stu-id="77331-116">Why is spatial mapping important?</span></span>

<span data-ttu-id="77331-117">利用空间映射，可以将对象放置在真实的图面上。</span><span class="sxs-lookup"><span data-stu-id="77331-117">Spatial mapping makes it possible to place objects on real surfaces.</span></span> <span data-ttu-id="77331-118">这有助于在用户世界定位对象，并利用真实的深度提示。基于其他全息影像和现实世界对象 Occluding 全息影像有助于说服用户这些全息影像实际位于其空间中。</span><span class="sxs-lookup"><span data-stu-id="77331-118">This helps anchor objects in the user's world and takes advantage of real world depth cues. Occluding your holograms based on other holograms and real world objects helps convince the user that these holograms are actually in their space.</span></span> <span data-ttu-id="77331-119">在空间中浮动或随用户移动的全息影像并不是真的。</span><span class="sxs-lookup"><span data-stu-id="77331-119">Holograms floating in space or moving with the user won't feel as real.</span></span> <span data-ttu-id="77331-120">如果可能，可轻松放置项目。</span><span class="sxs-lookup"><span data-stu-id="77331-120">When possible, place items for comfort.</span></span>

<span data-ttu-id="77331-121">放置或移动全息影像时显示表面 (使用投影网格) 。</span><span class="sxs-lookup"><span data-stu-id="77331-121">Visualize surfaces when placing or moving holograms (use a projected grid).</span></span> <span data-ttu-id="77331-122">这可以帮助用户了解他们最能最好地放置全息影像，并显示他们尝试放置全息影像的点是否未映射。</span><span class="sxs-lookup"><span data-stu-id="77331-122">This helps users know where they can best place their holograms, and shows if the spot they're trying to place the hologram isn't mapped.</span></span> <span data-ttu-id="77331-123">如果用户的角度太多，您可以向用户 "布告栏项目"。</span><span class="sxs-lookup"><span data-stu-id="77331-123">You can "billboard items" toward the user if they end up at too much of an angle.</span></span>

## <a name="conceptual-overview"></a><span data-ttu-id="77331-124">概念概述</span><span class="sxs-lookup"><span data-stu-id="77331-124">Conceptual overview</span></span>

<span data-ttu-id="77331-125">![覆盖房间的网格面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="77331-125">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="77331-126">*覆盖房间的空间映射网格示例*</span><span class="sxs-lookup"><span data-stu-id="77331-126">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="77331-127">用于空间映射的两个主要对象类型为 "空间图观察器" 和 "空间图面"。</span><span class="sxs-lookup"><span data-stu-id="77331-127">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="77331-128">应用程序为空间图面观察器提供一个或多个边界卷，以定义应用程序希望接收空间映射数据的空间区域。</span><span class="sxs-lookup"><span data-stu-id="77331-128">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="77331-129">对于其中每个卷，空间映射将为应用程序提供一组空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-129">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="77331-130">这些卷 (基于实际) 固定位置中的固定位置，或者它们可能会附加到 HoloLens (它们在 HoloLens 经过环境) 时移动但不旋转。</span><span class="sxs-lookup"><span data-stu-id="77331-130">These volumes may be stationary (in a fixed location based on the real world) or they may be attached to the HoloLens (they move, but don't rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="77331-131">每个空间图面描述了少量空间中的实际表面，这些表面表示为附加到世界锁定空间坐标系 的三角形 [网格](coordinate-systems.md)。</span><span class="sxs-lookup"><span data-stu-id="77331-131">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="77331-132">当 HoloLens 收集有关环境的新数据时，当环境发生更改时，空间图面将出现、消失和更改。</span><span class="sxs-lookup"><span data-stu-id="77331-132">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear, and change.</span></span>

## <a name="spatial-awareness-design-concepts-demo"></a><span data-ttu-id="77331-133">空间感知设计概念演示</span><span class="sxs-lookup"><span data-stu-id="77331-133">Spatial Awareness design concepts demo</span></span>

<span data-ttu-id="77331-134">若要了解空间感知设计概念的运行情况，请查看下面的设计 **全息影像 - 空间感知** 视频演示。</span><span class="sxs-lookup"><span data-stu-id="77331-134">If you'd like to see Spatial Awareness design concepts in action, check out our **Designing Holograms - Spatial Awareness** video demo below.</span></span> <span data-ttu-id="77331-135">完成后，请继续详细了解特定主题。</span><span class="sxs-lookup"><span data-stu-id="77331-135">When you've finished, continue on for a more detailed dive into specific topics.</span></span>

> [!VIDEO https://channel9.msdn.com/Shows/Docs-Mixed-Reality/Microsofts-Designing-Holograms-Spatial-Awareness-Chapter/player]

<span data-ttu-id="77331-136">*此视频取自"设计全息影像"HoloLens 2应用。在此处下载并享受完整 [体验](https://aka.ms/dhapp)。*</span><span class="sxs-lookup"><span data-stu-id="77331-136">*This video was taken from the "Designing Holograms" HoloLens 2 app. Download and enjoy the full experience [here](https://aka.ms/dhapp).*</span></span>

## <a name="spatial-mapping-vs-scene-understanding-worldmesh"></a><span data-ttu-id="77331-137">空间映射与场景理解 WorldMesh</span><span class="sxs-lookup"><span data-stu-id="77331-137">Spatial Mapping vs. Scene Understanding WorldMesh</span></span>

<span data-ttu-id="77331-138">对于HoloLens 2，可以查询静态版本的空间映射数据，使用场景理解 [SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh 设置) 。</span><span class="sxs-lookup"><span data-stu-id="77331-138">For HoloLens 2, it's possible to query a static version of the spatial mapping data using [Scene understanding SDK](../develop/platform-capabilities-and-apis/scene-understanding-SDK.md) (EnableWorldMesh setting).</span></span> <span data-ttu-id="77331-139">下面是访问空间映射数据的两种方法之间的差异：</span><span class="sxs-lookup"><span data-stu-id="77331-139">Here are the differences between two ways of accessing the spatial mapping data:</span></span>
* <span data-ttu-id="77331-140">空间映射 API：</span><span class="sxs-lookup"><span data-stu-id="77331-140">Spatial Mapping API:</span></span>
   * <span data-ttu-id="77331-141">有限范围：空间映射数据可用于用户周围缓存的"气泡"大小有限的应用程序。</span><span class="sxs-lookup"><span data-stu-id="77331-141">Limited range: the spatial mapping data available to applications in a limited size cached 'bubble' around the user.</span></span>
   * <span data-ttu-id="77331-142">通过 SurfacesChanged 事件提供更改的网格区域的低延迟更新。</span><span class="sxs-lookup"><span data-stu-id="77331-142">Provides low latency updates of changed mesh regions through SurfacesChanged events.</span></span>
   * <span data-ttu-id="77331-143">由"每三角形一个三角形"参数控制的详细信息的可变级别。</span><span class="sxs-lookup"><span data-stu-id="77331-143">Variable level of details controlled by Triangles Per Cubic Meter parameter.</span></span>
* <span data-ttu-id="77331-144">场景理解 SDK：</span><span class="sxs-lookup"><span data-stu-id="77331-144">Scene understanding SDK:</span></span>
   * <span data-ttu-id="77331-145">无限制范围 - 提供查询半径内所有扫描的空间映射数据。</span><span class="sxs-lookup"><span data-stu-id="77331-145">Unlimited range - provides all the scanned spatial mapping data within the query radius.</span></span>
   * <span data-ttu-id="77331-146">提供空间映射数据的静态快照。</span><span class="sxs-lookup"><span data-stu-id="77331-146">Provides a static snapshot of the spatial mapping data.</span></span> <span data-ttu-id="77331-147">获取更新的空间映射数据需要针对整个网格运行新查询。</span><span class="sxs-lookup"><span data-stu-id="77331-147">Getting the updated spatial mapping data requires running a new query for the whole mesh.</span></span>
   * <span data-ttu-id="77331-148">RequestedMeshLevelOfDetail 设置控制的详细信息的一致级别。</span><span class="sxs-lookup"><span data-stu-id="77331-148">Consistent level of details controlled by RequestedMeshLevelOfDetail setting.</span></span>

## <a name="what-influences-spatial-mapping-quality"></a><span data-ttu-id="77331-149">哪些因素会影响空间映射质量？</span><span class="sxs-lookup"><span data-stu-id="77331-149">What influences spatial mapping quality?</span></span>

<span data-ttu-id="77331-150">[此处](/hololens/hololens-environment-considerations)详细介绍的几个因素可能会影响这些错误的频率和严重性。</span><span class="sxs-lookup"><span data-stu-id="77331-150">Several factors, detailed [here](/hololens/hololens-environment-considerations), can affect the frequency and severity of these errors.</span></span>  <span data-ttu-id="77331-151">但是，你应设计应用程序，以便即使在空间映射数据中存在错误时，用户也可以实现其目标。</span><span class="sxs-lookup"><span data-stu-id="77331-151">However, you should design your application so that the user can achieve their goals even in the presence of errors in the spatial mapping data.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="77331-152">常见使用方案</span><span class="sxs-lookup"><span data-stu-id="77331-152">Common usage scenarios</span></span>

![常见空间映射使用方案的插图：放置、封闭、物理学和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="77331-154">放置</span><span class="sxs-lookup"><span data-stu-id="77331-154">Placement</span></span>

<span data-ttu-id="77331-155">空间映射为应用程序提供了向用户提供自然和熟悉的交互形式的机会。比将您的手机放在办公桌上的情况如何？</span><span class="sxs-lookup"><span data-stu-id="77331-155">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing down your phone on the desk?</span></span>

<span data-ttu-id="77331-156"> (或更常见地限制全息影像的位置，) 的任何空间位置选择都是在表面上，从空间) 的 3D (点到图面 (上的 2D) 点的自然映射。</span><span class="sxs-lookup"><span data-stu-id="77331-156">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="77331-157">这会减少用户提供给应用程序所需的信息量，并使用户的交互速度更快、更简单且更精确。</span><span class="sxs-lookup"><span data-stu-id="77331-157">This reduces the amount of information the user needs to provide to the application and makes the user's interactions faster, easier, and more precise.</span></span> <span data-ttu-id="77331-158">这是正确的，因为 "距离远离" 不是我们用于与其他人或计算机进行物理通信的东西。</span><span class="sxs-lookup"><span data-stu-id="77331-158">This is true because 'distance away' isn't something that we're used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="77331-159">当我们使用手指点时，我们指定的是一个方向，而不是距离。</span><span class="sxs-lookup"><span data-stu-id="77331-159">When we point with our finger, we're specifying a direction but not a distance.</span></span>

<span data-ttu-id="77331-160">下面是一个重要的注意事项：当应用程序从方向推断距离时 (例如，通过沿用户的注视方向 raycast 来查找最接近的空间图面) ，这必须生成用户可以可靠地预知的结果。</span><span class="sxs-lookup"><span data-stu-id="77331-160">An important caveat here's that when an application infers distance from direction (for example by doing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user can reliably predict.</span></span> <span data-ttu-id="77331-161">否则，用户将失去控制，这很快就会变得沮丧。</span><span class="sxs-lookup"><span data-stu-id="77331-161">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="77331-162">有助于实现此目的的一种方法是执行多个 raycasts，而不只是一个。</span><span class="sxs-lookup"><span data-stu-id="77331-162">One method that helps with this is to do multiple raycasts instead of just one.</span></span> <span data-ttu-id="77331-163">聚合结果应更平滑且更具可预测性，不会受到暂时性的 "离群" 结果的影响 (因为这可能是由于光线通过小孔而导致的，或者是用户不知道) 的小位几何导致的。</span><span class="sxs-lookup"><span data-stu-id="77331-163">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user isn't aware of).</span></span> <span data-ttu-id="77331-164">还可以在一段时间内执行聚合或平滑处理;例如，可以限制与用户之间的间距变化的最大速度。</span><span class="sxs-lookup"><span data-stu-id="77331-164">Aggregation or smoothing can also be performed over time; for example, you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="77331-165">仅限制最小和最大距离值也有所帮助，因此移动的全息影像不会突然离开距离或崩溃回到用户的面部。</span><span class="sxs-lookup"><span data-stu-id="77331-165">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved doesn't suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="77331-166">应用程序还可使用表面的形状和方向来引导全息影像放置。</span><span class="sxs-lookup"><span data-stu-id="77331-166">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="77331-167">全息大把不应穿过墙，并且应该与楼层一起刷新，即使它有点不均匀。</span><span class="sxs-lookup"><span data-stu-id="77331-167">A holographic chair shouldn't penetrate through walls and should sit flush with the floor even if it's slightly uneven.</span></span> <span data-ttu-id="77331-168">此类功能可能依赖于物理碰撞的使用，而不是光线广播，但类似的关注点将适用。</span><span class="sxs-lookup"><span data-stu-id="77331-168">This kind of functionality would likely rely upon the use of physics collisions rather than raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="77331-169">如果放置的全息影像具有许多小多边形（例如，在长脚上贴边）时，将这些多边形的物理表示形式扩展到更宽、更平滑的多边形，以便它们更能够在空间图面上滑动，而无需进行滑动。</span><span class="sxs-lookup"><span data-stu-id="77331-169">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they're more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="77331-170">在极端情况下，可以完全简化用户输入，空间图面可用于完全自动放置全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-170">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to do entirely automatic hologram placement.</span></span> <span data-ttu-id="77331-171">例如，应用程序可以在墙的某一位置放置全息光开关，供用户按下。</span><span class="sxs-lookup"><span data-stu-id="77331-171">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="77331-172">可预测性的相同注意事项在此处同时适用;如果用户希望控制全息影像的放置，但应用程序并不总是将全息影像放在预期的位置 (如果光开关出现在用户无法到达) 的位置，则这是一种令人沮丧的体验。</span><span class="sxs-lookup"><span data-stu-id="77331-172">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application doesn't always place holograms where they expect (if the light-switch appears somewhere that the user can't reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="77331-173">执行需要某些时间进行用户更正的自动放置实际上比仅要求用户始终自行进行放置要差;因为预期自动放置 *会成功*，所以手动更正就像一个负担！</span><span class="sxs-lookup"><span data-stu-id="77331-173">It can actually be worse to do automatic placement that requires user correction some of the time, than to just require the user to always do placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="77331-174">另请注意，应用程序使用空间图面进行放置的能力在很大程度上取决于应用程序的扫描 [体验](spatial-mapping.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="77331-174">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="77331-175">如果尚未扫描图面，则不能用于放置。</span><span class="sxs-lookup"><span data-stu-id="77331-175">If a surface hasn't been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="77331-176">由应用程序向用户表明这一点，以便他们可以帮助扫描新表面或选择新位置。</span><span class="sxs-lookup"><span data-stu-id="77331-176">It's up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="77331-177">在放置过程中，对用户的视觉反馈非常重要。</span><span class="sxs-lookup"><span data-stu-id="77331-177">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="77331-178">用户需要知道全息图基于具有 [接地效果](spatial-mapping.md#visualization)的最近图面。</span><span class="sxs-lookup"><span data-stu-id="77331-178">The user needs to know where the hologram is based on the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="77331-179">它们应了解为什么会对全息图的移动进行约束 (例如，因为与附近的另一个曲面) 发生冲突。</span><span class="sxs-lookup"><span data-stu-id="77331-179">They should understand why the movement of their hologram is being constrained (for example, because of collisions with another nearby surface).</span></span> <span data-ttu-id="77331-180">如果他们无法在当前位置放置全息影像，则视觉对象反馈应清楚地说明为什么不这样做。</span><span class="sxs-lookup"><span data-stu-id="77331-180">If they can't place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="77331-181">例如，如果用户尝试将全息的沙发卡在墙壁上，则墙后的沙发部分应 pulsate 为生气的颜色，。</span><span class="sxs-lookup"><span data-stu-id="77331-181">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="77331-182">相反，如果应用程序在用户可以看到真实表面的位置找不到空间图面，则应用程序应使其清晰。</span><span class="sxs-lookup"><span data-stu-id="77331-182">Or conversely, if the application can't find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="77331-183">此区域中明显不会产生接地效果的情况。</span><span class="sxs-lookup"><span data-stu-id="77331-183">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="77331-184">封闭</span><span class="sxs-lookup"><span data-stu-id="77331-184">Occlusion</span></span>

<span data-ttu-id="77331-185">空间映射图面的主要用途之一就是遮蔽全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-185">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="77331-186">这一简单的行为对全息影像的明显影响非常大，有助于创建 visceral 的意义，真正与用户 inhabits 相同的物理空间。</span><span class="sxs-lookup"><span data-stu-id="77331-186">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabits the same physical space as the user.</span></span>

<span data-ttu-id="77331-187">封闭还向用户提供信息;当现实世界图面上出现全息图时，这就为世界上该全息图的空间位置提供了额外的视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="77331-187">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides extra visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="77331-188">相反，封闭也可以有用 *隐藏* 用户的信息;occluding 的后台影像可以以直观的方式减少视觉干扰。</span><span class="sxs-lookup"><span data-stu-id="77331-188">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="77331-189">若要隐藏或显示全息图，用户只需移动其头。</span><span class="sxs-lookup"><span data-stu-id="77331-189">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="77331-190">封闭还可用于根据熟悉的物理交互，为自然用户界面提供合理的预期。如果某个图面的封闭像素是一个全息图，就是因为该表面是稳定的，因此用户应该认为，全息图将与该表面发生 *冲突* ，而不会通过它。</span><span class="sxs-lookup"><span data-stu-id="77331-190">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not pass through it.</span></span>

<span data-ttu-id="77331-191">有时，不需要封闭的全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-191">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="77331-192">如果用户需要与全息影像交互，则需要查看它，即使它位于真实表面后面。</span><span class="sxs-lookup"><span data-stu-id="77331-192">If a user needs to interact with a hologram, then they need to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="77331-193">在这种情况下，在遮挡此类全息影像时，以不同方式呈现 (例如，降低其亮度) 。</span><span class="sxs-lookup"><span data-stu-id="77331-193">In such cases, it usually makes sense to render such a hologram differently when it's occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="77331-194">这样，用户就可以直观地找到全息影像，但他们仍然知道它位于某一位置后面。</span><span class="sxs-lookup"><span data-stu-id="77331-194">This way, the user can visually locate the hologram, but they'll still know it's behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="77331-195">物理</span><span class="sxs-lookup"><span data-stu-id="77331-195">Physics</span></span>

<span data-ttu-id="77331-196">使用物理模拟是空间映射的另一种方式，可用于强化用户物理空间中全息影像的存在。 </span><span class="sxs-lookup"><span data-stu-id="77331-196">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="77331-197">当我的全息球从我的台子上真实地滚出时，在楼层中弹跳并消失在树下时，我可能很难认为它不存在。</span><span class="sxs-lookup"><span data-stu-id="77331-197">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not there.</span></span>

<span data-ttu-id="77331-198">物理模拟还为应用程序提供了使用自然和熟悉的基于物理的交互的机会。</span><span class="sxs-lookup"><span data-stu-id="77331-198">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="77331-199">如果用户在楼层四处移动一块全息影像，用户可能会更轻松地响应，就像它通过适当的惯性和摩擦在楼层上滑动一样。</span><span class="sxs-lookup"><span data-stu-id="77331-199">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="77331-200">若要生成真实的物理行为，可能需要执行一些网格处理，例如[](spatial-mapping.md#mesh-processing)填充孔、移除浮动的形像和平滑粗糙表面。</span><span class="sxs-lookup"><span data-stu-id="77331-200">To generate realistic physical behaviors, you'll likely need to do some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="77331-201">还需要考虑应用程序的扫描体验 [如何影响其物理](spatial-mapping.md#the-environment-scanning-experience) 模拟。</span><span class="sxs-lookup"><span data-stu-id="77331-201">You'll also need to consider how your application's [scanning experience](spatial-mapping.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="77331-202">首先，缺失的图面不会与任何内容冲突;当滚球从已知世界末尾向下滚下时会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="77331-202">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="77331-203">其次，需要决定是否继续响应环境中一段时间的变化。</span><span class="sxs-lookup"><span data-stu-id="77331-203">Secondly, you need to decide whether you'll continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="77331-204">在某些情况下，需要尽快做出响应;假设用户使用门和建筑作为可移动门架，以防御传入的拉丁语箭头的风暴。</span><span class="sxs-lookup"><span data-stu-id="77331-204">In some cases, you'll want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="77331-205">但是，在其他情况下，你可能想要忽略新更新;如果狗决定坐在轨道中间，那么在楼层的自行车道周围驾驶全息运动汽车可能突然变得不是那么有趣。</span><span class="sxs-lookup"><span data-stu-id="77331-205">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="77331-206">导航</span><span class="sxs-lookup"><span data-stu-id="77331-206">Navigation</span></span>

<span data-ttu-id="77331-207">应用程序可以使用空间映射数据 (或代理授予全息字符，) 能够以真实人员的相同方式浏览现实。</span><span class="sxs-lookup"><span data-stu-id="77331-207">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="77331-208">这可以通过将其限制为用户及其好友的一组自然、熟悉的行为来帮助强化是否存在全息字符。</span><span class="sxs-lookup"><span data-stu-id="77331-208">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="77331-209">导航功能对于用户也很有用。</span><span class="sxs-lookup"><span data-stu-id="77331-209">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="77331-210">在给定区域中生成导航地图后，可以将其共享，为不熟悉该位置的新用户提供全息说明。</span><span class="sxs-lookup"><span data-stu-id="77331-210">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="77331-211">此映射可用于帮助保持行人的流量顺畅地流动，或避免在危险位置（如构造站点）中发生意外。</span><span class="sxs-lookup"><span data-stu-id="77331-211">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="77331-212">实现导航功能所涉及的关键技术挑战将会对不可的表面进行可靠检测， (人们不会对表进行检查！ ) 并正常地适应环境中的变化 (人类不会遍历关闭的门！ ) 。</span><span class="sxs-lookup"><span data-stu-id="77331-212">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="77331-213">网格可能需要进行一些 [处理](spatial-mapping.md#mesh-processing) 才能用于通过虚拟字符进行路径规划和导航。</span><span class="sxs-lookup"><span data-stu-id="77331-213">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it's usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="77331-214">平滑网格和删除 hallucinations 可帮助避免字符停滞。</span><span class="sxs-lookup"><span data-stu-id="77331-214">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="77331-215">你可能还希望大幅简化网格，提高字符的路径规划和导航计算速度。</span><span class="sxs-lookup"><span data-stu-id="77331-215">You may also wish to drastically simplify the mesh to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="77331-216">在开发视频游戏技术时，这些挑战已经得到了很大的关注，其中提供了大量有关这些主题的信息。</span><span class="sxs-lookup"><span data-stu-id="77331-216">These challenges have received a great deal of attention in the development of video game technology, and there's a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="77331-217">Unity 中的内置 NavMesh 功能不能与空间映射图面一起使用。</span><span class="sxs-lookup"><span data-stu-id="77331-217">The built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="77331-218">这是因为在应用程序启动之前空间映射图面是未知的，但需要提前从源资产生成 NavMesh 数据文件。</span><span class="sxs-lookup"><span data-stu-id="77331-218">This is because spatial mapping surfaces aren't known until the application starts, but NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="77331-219">另请注意，空间映射系统不会提供与用户当前位置 [有关的有关表面的信息](spatial-mapping.md#the-environment-scanning-experience) 。</span><span class="sxs-lookup"><span data-stu-id="77331-219">Also note that, the spatial mapping system won't provide [information about surfaces far away](spatial-mapping.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="77331-220">因此，如果要构建大区域的地图，应用程序必须 "记住" 自身。</span><span class="sxs-lookup"><span data-stu-id="77331-220">So the application must 'remember' surfaces itself if it's to build a map of a large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="77331-221">可视化效果</span><span class="sxs-lookup"><span data-stu-id="77331-221">Visualization</span></span>

<span data-ttu-id="77331-222">大多数情况下，空间图面是可见的;以最大程度地减少视觉混乱，让现实世界代表自己。</span><span class="sxs-lookup"><span data-stu-id="77331-222">Most of the time it's appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="77331-223">但是，有时直接可视化空间映射图面很有用，尽管它们的实际对应图面可见。</span><span class="sxs-lookup"><span data-stu-id="77331-223">However, sometimes it's useful to visualize spatial mapping surfaces directly, despite their real-world counterparts being visible.</span></span>

<span data-ttu-id="77331-224">例如，当用户尝试将全息影像放置到图面上时 (将全息箱放在墙上（例如) 将阴影投射到图面上来"地面"全息影像会很有用。</span><span class="sxs-lookup"><span data-stu-id="77331-224">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="77331-225">这样，用户就更清楚地了解全息影像和表面之间的完全物理邻近性。</span><span class="sxs-lookup"><span data-stu-id="77331-225">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="77331-226">这也是在用户提交更改之前直观地"预览"更改的更一般做法示例。</span><span class="sxs-lookup"><span data-stu-id="77331-226">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="77331-227">通过可视化图面，应用程序可以与用户共享其环境理解。</span><span class="sxs-lookup"><span data-stu-id="77331-227">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="77331-228">例如，全息棋盘游戏可以可视化它标识为"表"的水平图面，以便用户知道他们应在何处进行交互。</span><span class="sxs-lookup"><span data-stu-id="77331-228">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="77331-229">可视化图面是向用户显示隐藏在视图中的附近空间的一种有用方法。</span><span class="sxs-lookup"><span data-stu-id="77331-229">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="77331-230">这可以提供一种方法，让用户能够访问其 (及其包含的所有全息影像) 来自其房间。</span><span class="sxs-lookup"><span data-stu-id="77331-230">This could provide a way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="77331-231">空间映射提供的表面网格可能并不特别"干净"。</span><span class="sxs-lookup"><span data-stu-id="77331-231">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="77331-232">正确可视化它们非常重要。</span><span class="sxs-lookup"><span data-stu-id="77331-232">It's important to visualize them appropriately.</span></span> <span data-ttu-id="77331-233">传统的照明计算可能会以视觉上分散注意力的方式突出显示表面法线中的错误，而投射到图面上的"干净"纹理可能有助于赋予其更简洁的外观。</span><span class="sxs-lookup"><span data-stu-id="77331-233">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, while 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="77331-234">在呈现图面之前，还可以[](spatial-mapping.md#mesh-processing)执行网格处理以改进网格属性。</span><span class="sxs-lookup"><span data-stu-id="77331-234">It's also possible to do [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

> [!NOTE]
> <span data-ttu-id="77331-235">HoloLens 2实现新的场景理解运行时 [，它为](scene-understanding.md)混合现实开发人员提供了结构化的高级别环境表示形式，旨在简化放置、遮挡、物理和导航的实现。</span><span class="sxs-lookup"><span data-stu-id="77331-235">HoloLens 2 implements a new [Scene Understanding Runtime](scene-understanding.md), that provides Mixed Reality developers with a structured, high-level environment representation designed to simplify the implementation of placement, occlusion, physics and navigation.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="77331-236">使用 Surface Observer</span><span class="sxs-lookup"><span data-stu-id="77331-236">Using The Surface Observer</span></span>

<span data-ttu-id="77331-237">空间映射的起点是表面观察器。</span><span class="sxs-lookup"><span data-stu-id="77331-237">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="77331-238">程序流如下所示：</span><span class="sxs-lookup"><span data-stu-id="77331-238">Program flow is as follows:</span></span>
* <span data-ttu-id="77331-239">创建 surface 观察器对象</span><span class="sxs-lookup"><span data-stu-id="77331-239">Create a surface observer object</span></span>
   * <span data-ttu-id="77331-240">提供一个或多个空间卷，以定义应用程序希望接收空间映射数据的感兴趣的区域。</span><span class="sxs-lookup"><span data-stu-id="77331-240">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="77331-241">空间量只是定义空间区域的形状，例如球或 box。</span><span class="sxs-lookup"><span data-stu-id="77331-241">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="77331-242">使用带有世界锁定的空间坐标系统的空间量来识别物理世界的固定区域。</span><span class="sxs-lookup"><span data-stu-id="77331-242">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="77331-243">使用空间量，使用正文锁定的空间坐标系统更新每个帧，以标识移动 (但不会向用户旋转) 的空间区域。</span><span class="sxs-lookup"><span data-stu-id="77331-243">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but doesn't rotate) with the user.</span></span>
   * <span data-ttu-id="77331-244">以后可以随时更改这些空间卷，因为应用程序或用户的状态会发生更改。</span><span class="sxs-lookup"><span data-stu-id="77331-244">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="77331-245">使用轮询或通知来检索有关空间图面的信息</span><span class="sxs-lookup"><span data-stu-id="77331-245">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="77331-246">您可以随时 "轮询" 面观察器来实现空间图面状态。</span><span class="sxs-lookup"><span data-stu-id="77331-246">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="77331-247">相反，你可以注册 surface 观察器的 "表面变化" 事件，这将在空间图面改变时通知应用程序。</span><span class="sxs-lookup"><span data-stu-id="77331-247">Instead, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="77331-248">对于动态空间量（如视图截锥或正文锁定卷），应用程序需要通过设置感兴趣的区域，然后获取当前的空间图面集来轮询每个帧的更改。</span><span class="sxs-lookup"><span data-stu-id="77331-248">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="77331-249">对于静态卷（如涵盖单个房间的全球锁定的多维数据集），应用程序可能会注册 "已更改" 事件，以便在该卷内的空间表面发生变化时得到通知。</span><span class="sxs-lookup"><span data-stu-id="77331-249">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="77331-250">处理表面更改</span><span class="sxs-lookup"><span data-stu-id="77331-250">Process surfaces changes</span></span>
   * <span data-ttu-id="77331-251">循环访问提供的空间图面集。</span><span class="sxs-lookup"><span data-stu-id="77331-251">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="77331-252">按添加、更改或删除的方式对空间图面进行分类。</span><span class="sxs-lookup"><span data-stu-id="77331-252">Classify spatial surfaces as added, changed, or removed.</span></span>
   * <span data-ttu-id="77331-253">对于每个已添加或已更改的空间图面，如果适当，请提交一个异步请求，以在所需的详细信息级别接收表示该图面的当前状态的已更新网格。</span><span class="sxs-lookup"><span data-stu-id="77331-253">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="77331-254">)  (以下部分中的详细信息，处理异步网格请求。</span><span class="sxs-lookup"><span data-stu-id="77331-254">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="77331-255">网格缓存</span><span class="sxs-lookup"><span data-stu-id="77331-255">Mesh Caching</span></span>

<span data-ttu-id="77331-256">空间图面由密集三角形网格表示。</span><span class="sxs-lookup"><span data-stu-id="77331-256">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="77331-257">存储、呈现和处理这些网格可能会占用大量计算和存储资源。</span><span class="sxs-lookup"><span data-stu-id="77331-257">Storing, rendering, and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="77331-258">因此，每个应用程序都应采用适合其需求的网格缓存方案，以最大程度地减少用于网格处理和存储的资源。</span><span class="sxs-lookup"><span data-stu-id="77331-258">As such, each application should adopt a mesh caching scheme appropriate to its needs, to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="77331-259">此方案应确定要保留的网格以及要丢弃的网格，以及何时更新每个空间图面的网格。</span><span class="sxs-lookup"><span data-stu-id="77331-259">This scheme should determine which meshes to keep and which to discard, and when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="77331-260">其中讨论的许多注意事项将直接告知应用程序应如何处理网格缓存。</span><span class="sxs-lookup"><span data-stu-id="77331-260">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="77331-261">应考虑用户如何在环境中移动（需要哪种表面、何时观察不同的表面以及何时应捕获环境中的更改）。</span><span class="sxs-lookup"><span data-stu-id="77331-261">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="77331-262">解释图面观察器提供的"surfaces changed"事件时，基本网格缓存逻辑如下所示：</span><span class="sxs-lookup"><span data-stu-id="77331-262">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="77331-263">如果应用程序看到以前未看到的空间图面 ID，则它应认为这是一个新的空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-263">If the application sees a spatial surface ID that it hasn't seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="77331-264">如果应用程序看到具有已知 ID 但具有新更新时间的空间图面，则它应视为已更新的空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-264">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="77331-265">如果应用程序不再看到具有已知 ID 的空间图面，则它应将其视为已删除的空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-265">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="77331-266">然后，由每个应用程序做出以下选择：</span><span class="sxs-lookup"><span data-stu-id="77331-266">It's up to each application to then make the following choices:</span></span>
* <span data-ttu-id="77331-267">对于新的空间图面，应请求网格吗？</span><span class="sxs-lookup"><span data-stu-id="77331-267">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="77331-268">通常，应该立即为新的空间图面请求网格，这可能为用户提供有用的新信息。</span><span class="sxs-lookup"><span data-stu-id="77331-268">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="77331-269">但是，应优先处理用户前后的新空间图面，并首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="77331-269">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="77331-270">如果不需要新网格，例如，如果应用程序已永久或暂时"冻结"其环境模型，则不应请求它。</span><span class="sxs-lookup"><span data-stu-id="77331-270">If the new mesh isn't needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it shouldn't be requested.</span></span>
* <span data-ttu-id="77331-271">对于更新的空间图面，应请求网格吗？</span><span class="sxs-lookup"><span data-stu-id="77331-271">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="77331-272">应优先处理用户前后更新的空间图面，并首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="77331-272">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="77331-273">新图面的优先级可能高于更新后的图面，尤其是在扫描体验期间。</span><span class="sxs-lookup"><span data-stu-id="77331-273">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="77331-274">为了限制处理成本，应用程序可能希望限制它们处理空间图面更新的速率。</span><span class="sxs-lookup"><span data-stu-id="77331-274">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="77331-275">可以推断出对空间图面所做的更改很小，例如，如果图面的边界很小，则更新可能不太重要，无法处理。</span><span class="sxs-lookup"><span data-stu-id="77331-275">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="77331-276">对于用户感兴趣的当前区域之外的空间表面的更新，可能会完全忽略，但是在这种情况下，修改 surface 观察器使用的空间边界卷可能更有效。</span><span class="sxs-lookup"><span data-stu-id="77331-276">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="77331-277">对于删除的空间表面，是否应丢弃网格？</span><span class="sxs-lookup"><span data-stu-id="77331-277">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="77331-278">通常应为删除的空间图面立即丢弃网格，使全息图封闭保持正确。</span><span class="sxs-lookup"><span data-stu-id="77331-278">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="77331-279">但是，如果应用程序有理由相信某个空间图面很快就会重新出现 (基于用户体验) 的设计，则保留该网格比丢弃其网格并稍后重新创建它可能更有效。</span><span class="sxs-lookup"><span data-stu-id="77331-279">However, if the application has reason to believe that a spatial surface will reappear shortly (based upon the design of the user experience), then it may be more efficient to keep it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="77331-280">如果应用程序正在生成用户环境的大规模模型，则可能根本不想丢弃任何网格。</span><span class="sxs-lookup"><span data-stu-id="77331-280">If the application is building a large-scale model of the user's environment, then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="77331-281">不过，它仍需要限制资源使用情况，可能通过将网格后台打印到磁盘，因为空间图面消失。</span><span class="sxs-lookup"><span data-stu-id="77331-281">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="77331-282">在空间表面生成过程中，某些相对罕见的事件可能会导致空间图面替换为类似位置但 Id 不同的新空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-282">Some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="77331-283">因此，选择不放弃已移除表面的应用程序应注意不会有多个高度重叠的空间表面，网格覆盖同一位置。</span><span class="sxs-lookup"><span data-stu-id="77331-283">So, applications that choose not to discard a removed surface should take care not to end up with multiple highly overlapped spatial surfaces meshes covering the same location.</span></span>
* <span data-ttu-id="77331-284">是否应为任何其他空间图面丢弃网格？</span><span class="sxs-lookup"><span data-stu-id="77331-284">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="77331-285">即使存在空间图面，如果它对用户体验不再有用，则应将其丢弃。</span><span class="sxs-lookup"><span data-stu-id="77331-285">Even while a spatial surface exists, if it's no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="77331-286">例如，如果应用程序 "将门口的另一侧的空间替换为备用虚拟空间，则该房间中的空间表面将不再重要。</span><span class="sxs-lookup"><span data-stu-id="77331-286">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="77331-287">下面是使用空间和时态滞后的示例网状缓存策略：</span><span class="sxs-lookup"><span data-stu-id="77331-287">Here's an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="77331-288">请考虑一个应用程序，该应用程序希望使用用户四处查看和四处移动时跟随用户凝视的 frustum 形空间音量。</span><span class="sxs-lookup"><span data-stu-id="77331-288">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="77331-289">空间图面可能会暂时从此卷中消失，因为用户离开该图面或离它更远一点...仅回顾一下，或稍后再进一步。</span><span class="sxs-lookup"><span data-stu-id="77331-289">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="77331-290">在这种情况下，放弃和重新创建此图面的网格表示许多冗余处理。</span><span class="sxs-lookup"><span data-stu-id="77331-290">In this case, discarding and re-creating the mesh for this surface represents many redundant processings.</span></span>
* <span data-ttu-id="77331-291">为了减少处理的更改数，应用程序使用两个空间图面观察程序，一个包含在另一个空间图面观察程序内。</span><span class="sxs-lookup"><span data-stu-id="77331-291">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="77331-292">较大的卷是球面的，并跟随用户"延迟";它仅在需要时移动，以确保其中心在用户 2.0 米范围内。</span><span class="sxs-lookup"><span data-stu-id="77331-292">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its center is within 2.0 meters of the user.</span></span>
* <span data-ttu-id="77331-293">新的和更新的空间图面网格始终从较小的内部表面观察程序进行处理，但网格会进行缓存，直到它们从较大的外部表面观察程序消失。</span><span class="sxs-lookup"><span data-stu-id="77331-293">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="77331-294">这样，应用程序可以避免由于本地用户移动而处理许多冗余更改。</span><span class="sxs-lookup"><span data-stu-id="77331-294">This allows the application to avoid processing many redundant changes because of local user movement.</span></span>
* <span data-ttu-id="77331-295">由于空间图面也可能因跟踪丢失而暂时消失，因此应用程序还会在跟踪丢失期间延迟丢弃已删除的空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-295">Since a spatial surface may also disappear temporarily because of tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="77331-296">通常，应用程序应评估更新处理减少与内存使用量增加之间的权衡，以确定其理想的缓存策略。</span><span class="sxs-lookup"><span data-stu-id="77331-296">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="77331-297">渲染</span><span class="sxs-lookup"><span data-stu-id="77331-297">Rendering</span></span>

<span data-ttu-id="77331-298">空间映射网格倾向于使用三种主要方式进行呈现：</span><span class="sxs-lookup"><span data-stu-id="77331-298">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="77331-299">对于图面可视化</span><span class="sxs-lookup"><span data-stu-id="77331-299">For surface visualization</span></span>
   * <span data-ttu-id="77331-300">直接可视化空间图面通常很有用。</span><span class="sxs-lookup"><span data-stu-id="77331-300">It's often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="77331-301">例如，将对象中的"阴影"强制转换到空间图面上，可以在用户将全息影像放置在图面上时为用户提供有用的视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="77331-301">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they're placing holograms on surfaces.</span></span>
   * <span data-ttu-id="77331-302">请记住，空间网格不同于 3D 艺术家可能创建的网格类型。</span><span class="sxs-lookup"><span data-stu-id="77331-302">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="77331-303">三角形拓扑不会像人工创建的拓扑一样"干净"，网格将遭受 [各种错误](spatial-mapping.md#what-influences-spatial-mapping-quality)。</span><span class="sxs-lookup"><span data-stu-id="77331-303">The triangle topology won't be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="77331-304">若要创建令人满意的视觉对象美观，可能需要进行一些 [网格处理](spatial-mapping.md#mesh-processing)，例如填充孔或平滑曲面法。</span><span class="sxs-lookup"><span data-stu-id="77331-304">To create a pleasing visual aesthetic, you may want to do some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="77331-305">您还可能希望使用着色器将艺术家设计的纹理投影到网格上，而不是直接可视化网格拓扑和法线。</span><span class="sxs-lookup"><span data-stu-id="77331-305">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="77331-306">对于真实的图面后面的 occluding 全息影像</span><span class="sxs-lookup"><span data-stu-id="77331-306">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="77331-307">空间图面可以在仅深度传递中呈现，这只会影响 [深度缓冲区](/windows/win32/direct3d9/depth-buffers) 并且不会影响颜色呈现器目标。</span><span class="sxs-lookup"><span data-stu-id="77331-307">Spatial surfaces can be rendered in a depth-only pass, which only affects the [depth buffer](/windows/win32/direct3d9/depth-buffers) and doesn't affect color render targets.</span></span>
   * <span data-ttu-id="77331-308">这 primes 了深度缓冲区，遮蔽随后在空间图面后面呈现全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-308">This primes the depth buffer to occlude subsequently rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="77331-309">最准确的全息影像封闭增强了全息影像在用户的物理空间内确实存在的意义。</span><span class="sxs-lookup"><span data-stu-id="77331-309">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="77331-310">若要启用仅深度渲染，请更新混合状态，将所有颜色渲染目标的 [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) 设置为零。</span><span class="sxs-lookup"><span data-stu-id="77331-310">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](/windows/win32/api/d3d11_1/ns-d3d11_1-d3d11_render_target_blend_desc1) to zero for all color render targets.</span></span>
* <span data-ttu-id="77331-311">用于修改真实环境中全息图封闭像素的外观</span><span class="sxs-lookup"><span data-stu-id="77331-311">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="77331-312">当封闭像素时，通常会隐藏呈现的几何图形。</span><span class="sxs-lookup"><span data-stu-id="77331-312">Normally rendered geometry is hidden when it's occluded.</span></span> <span data-ttu-id="77331-313">这是通过将 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) 中的深度函数设置为 "小于或等于" 来实现的，这会使几何仅在 **离相机更近** 的位置（而不是所有先前呈现的几何）可见。</span><span class="sxs-lookup"><span data-stu-id="77331-313">This is achieved by setting the depth function in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc) to "less than or equal", which causes geometry to be visible only where it's **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="77331-314">但是，在某些情况下，即使在封闭像素时也能看到某些几何，并在封闭像素作为向用户提供视觉反馈时修改其外观。</span><span class="sxs-lookup"><span data-stu-id="77331-314">However, it may be useful to keep certain geometry visible even when it's occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="77331-315">例如，这允许应用程序向用户显示对象的位置，同时使其清楚地显示在实际表面。</span><span class="sxs-lookup"><span data-stu-id="77331-315">For example, this allows the application to show the user the location of an object while making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="77331-316">若要实现此目的，请使用另一个创建所需 "封闭像素" 外观的着色器第二次渲染几何。</span><span class="sxs-lookup"><span data-stu-id="77331-316">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="77331-317">在第二次渲染几何之前，对 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)进行两次更改。</span><span class="sxs-lookup"><span data-stu-id="77331-317">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="77331-318">首先，将 "深度函数" 设置为 "大于或等于"，以便仅在 **其从相机中看到** 的位置比之前呈现的所有几何都可见。</span><span class="sxs-lookup"><span data-stu-id="77331-318">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it's **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="77331-319">其次，将 DepthWriteMask 设置为零，以便深度缓冲区不会修改 (因为深度缓冲区应继续表示离相机区域最近的几何图形) 。 </span><span class="sxs-lookup"><span data-stu-id="77331-319">Second, set the DepthWriteMask to zero, so that the depth buffer won't be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="77331-320">[呈现](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) 空间映射网格时，性能是一个重要的问题。</span><span class="sxs-lookup"><span data-stu-id="77331-320">[Performance](../develop/platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="77331-321">下面是一些特定于呈现空间映射网格的呈现性能技术：</span><span class="sxs-lookup"><span data-stu-id="77331-321">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="77331-322">调整三角形密度</span><span class="sxs-lookup"><span data-stu-id="77331-322">Adjust triangle density</span></span>
   * <span data-ttu-id="77331-323">从表面观察器请求空间图面网格时，请请求满足你需求的三角形网格的最低密度。</span><span class="sxs-lookup"><span data-stu-id="77331-323">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="77331-324">根据表面与用户的距离及其与用户体验的相关性，按表面改变三角形密度可能很有意义。</span><span class="sxs-lookup"><span data-stu-id="77331-324">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="77331-325">减少三角形计数会降低 GPU 上的内存使用量和顶点处理成本，但不会影响像素处理成本。</span><span class="sxs-lookup"><span data-stu-id="77331-325">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it won't affect pixel processing costs.</span></span>
* <span data-ttu-id="77331-326">使用 frustum 剔除</span><span class="sxs-lookup"><span data-stu-id="77331-326">Use frustum culling</span></span>
   * <span data-ttu-id="77331-327">Frustum 剔除会跳过无法看到的绘图对象，因为它们位于当前显示图面之外。</span><span class="sxs-lookup"><span data-stu-id="77331-327">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="77331-328">这降低了 CPU 和 GPU 处理成本。</span><span class="sxs-lookup"><span data-stu-id="77331-328">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="77331-329">由于基于每个网格执行剔除，并且空间图面可能很大，因此将每个空间图面网格分解为较小的区块可能会导致更高效的剔除 (因为屏幕外三角形呈现) 。</span><span class="sxs-lookup"><span data-stu-id="77331-329">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="77331-330">但是，有一个权衡;网格数越多，必须进行绘制调用就更多，这会增加 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="77331-330">There's a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="77331-331">在极端情况下，frustum 剔除计算本身甚至可以具有可度量的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="77331-331">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="77331-332">调整呈现顺序</span><span class="sxs-lookup"><span data-stu-id="77331-332">Adjust rendering order</span></span>
   * <span data-ttu-id="77331-333">空间图面往往很大，因为它们表示用户周围的整个环境。</span><span class="sxs-lookup"><span data-stu-id="77331-333">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="77331-334">GPU 上的像素处理成本可能很高，尤其是在存在多个可见几何图形层的情况下 (包括空间图和其他全息影像) 。</span><span class="sxs-lookup"><span data-stu-id="77331-334">Pixel processing costs on the GPU can be high, especially in cases where there's more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="77331-335">在这种情况下，离用户最近的层会进一步遮挡任何层，因此呈现这些较远的层所花费的任何 GPU 时间都将浪费。</span><span class="sxs-lookup"><span data-stu-id="77331-335">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="77331-336">若要减少 GPU 上的这一冗余工作，这有助于在最接近的情况下，以从上到下的顺序呈现不透明的图面， (上一次) 。</span><span class="sxs-lookup"><span data-stu-id="77331-336">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="77331-337">"不透明" 是指在您的 [深度模具状态](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc)中将 DepthWriteMask 设置为一个的表面。</span><span class="sxs-lookup"><span data-stu-id="77331-337">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](/windows/win32/api/d3d11/ns-d3d11-d3d11_depth_stencil_desc).</span></span> <span data-ttu-id="77331-338">当呈现最近的图面时，它们将为深度缓冲区的质数，以便 GPU 上的像素处理器能够有效地跳过更远的图面。</span><span class="sxs-lookup"><span data-stu-id="77331-338">When the nearest surfaces are rendered, they'll prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="77331-339">网格处理</span><span class="sxs-lookup"><span data-stu-id="77331-339">Mesh Processing</span></span>

<span data-ttu-id="77331-340">应用程序可能希望对空间 surface 网格执行 [各种操作](spatial-mapping.md#mesh-processing) 以满足其需求。</span><span class="sxs-lookup"><span data-stu-id="77331-340">An application may want to do [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="77331-341">每个空间 surface 网格提供的索引和顶点数据与用于在所有新式渲染 Api 中呈现三角形网格的 [顶点和索引缓冲区](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) 使用的布局相同。</span><span class="sxs-lookup"><span data-stu-id="77331-341">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](/windows/win32/direct3d9/rendering-from-vertex-and-index-buffers) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="77331-342">不过，有一个关键事实需要注意的是，空间映射三角形具有 **前后的缠绕顺序**。</span><span class="sxs-lookup"><span data-stu-id="77331-342">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="77331-343">每个三角形都用网格的索引缓冲区中的三个顶点索引表示，当从 **正面** 查看三角形时，这些索引会按 **顺时针** 顺序标识三角形的顶点。</span><span class="sxs-lookup"><span data-stu-id="77331-343">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="77331-344">空间 surface 网格的正面 (或外部) 与您预期在实际表面的正面 () 可见。</span><span class="sxs-lookup"><span data-stu-id="77331-344">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="77331-345">如果 surface 观察器提供的益处三角形密度仍不足粗，则应用程序应仅执行网格简化，这种工作的计算成本非常高，且已由运行时执行以生成各种提供的详细信息级别。</span><span class="sxs-lookup"><span data-stu-id="77331-345">Applications should only do mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="77331-346">由于每个 surface 观察器都可以提供多个未连接的空间图面，因此某些应用程序可能希望彼此剪裁这些空间 surface 网格，然后将它们 zipper 在一起。</span><span class="sxs-lookup"><span data-stu-id="77331-346">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="77331-347">通常，剪裁步骤是必需的，因为附近的空间 surface 网格通常会稍微重叠。</span><span class="sxs-lookup"><span data-stu-id="77331-347">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="77331-348">Raycasting 和冲突</span><span class="sxs-lookup"><span data-stu-id="77331-348">Raycasting and Collision</span></span>

<span data-ttu-id="77331-349">为了使物理 API (例如 [Havok](https://www.havok.com/)) 为应用程序提供空间图面的光线广播和碰撞功能，应用程序必须为物理 API 提供空间表面网格。</span><span class="sxs-lookup"><span data-stu-id="77331-349">In order for a physics API (such as [Havok](https://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="77331-350">用于物理的网格通常具有以下属性：</span><span class="sxs-lookup"><span data-stu-id="77331-350">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="77331-351">它们仅包含少量三角形。</span><span class="sxs-lookup"><span data-stu-id="77331-351">They contain only small numbers of triangles.</span></span> <span data-ttu-id="77331-352">物理运算比渲染操作的计算密集型更多。</span><span class="sxs-lookup"><span data-stu-id="77331-352">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="77331-353">它们"水很紧"。</span><span class="sxs-lookup"><span data-stu-id="77331-353">They're 'water-tight'.</span></span> <span data-ttu-id="77331-354">旨在为实心的图面中不应有小孔;即使小到不可见的孔也可能会导致问题。</span><span class="sxs-lookup"><span data-stu-id="77331-354">Surfaces intended to be solid shouldn't have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="77331-355">它们被转换为凸包。</span><span class="sxs-lookup"><span data-stu-id="77331-355">They're converted into convex hulls.</span></span> <span data-ttu-id="77331-356">凸包具有很少的多边形且没有孔，并且其处理计算效率比原始三角形网格要高效得多。</span><span class="sxs-lookup"><span data-stu-id="77331-356">Convex hulls have few polygons and are free of holes, and they're much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="77331-357">对空间图面进行光线广播时，请记住，这些表面通常是复杂、杂乱的形状，包含杂乱的小细节 -就像桌面一样！</span><span class="sxs-lookup"><span data-stu-id="77331-357">When doing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="77331-358">这意味着，单个光线广播通常不足以提供有关表面形状及其附近空白空间形状的足够信息。</span><span class="sxs-lookup"><span data-stu-id="77331-358">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="77331-359">通常，建议在一个小区域中执行多个光线广播，并使用聚合结果获得对表面更可靠的理解。</span><span class="sxs-lookup"><span data-stu-id="77331-359">It's usually a good idea to do many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="77331-360">例如，使用平均 10 个光线广播来引导全息影像在表面上放置，将生成一种更平滑且不太"抖动"的结果，因为只需使用一个光线广播。</span><span class="sxs-lookup"><span data-stu-id="77331-360">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="77331-361">但是，请记住，每个光线广播的计算成本可能很高。</span><span class="sxs-lookup"><span data-stu-id="77331-361">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="77331-362">根据你的使用方案，应该将每个帧 () 完成的额外光线广播的计算成本与网格处理的计算成本进行平衡，以在空间网格更新) [](spatial-mapping.md#mesh-processing)时平滑和移除空间 (中的孔。</span><span class="sxs-lookup"><span data-stu-id="77331-362">Depending on your usage scenario, you should trade off the computational cost of extra raycasts (done every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (done when spatial meshes are updated).</span></span>

## <a name="the-environment-scanning-experience"></a><span data-ttu-id="77331-363">环境扫描体验</span><span class="sxs-lookup"><span data-stu-id="77331-363">The environment scanning experience</span></span>

<span data-ttu-id="77331-364">使用空间映射的每个应用程序都应考虑提供"扫描体验";应用程序引导用户扫描应用程序正常运行所需的表面的过程。</span><span class="sxs-lookup"><span data-stu-id="77331-364">Each application that uses spatial mapping should consider providing a 'scanning experience'; the process through which the application guides the user to scan surfaces that are necessary for the application to function correctly.</span></span>

<span data-ttu-id="77331-365">![扫描示例](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span><span class="sxs-lookup"><span data-stu-id="77331-365">![Example of scanning](images/sr-mixedworld-140429-8pm-00068-1000px.png)</span></span><br>
<span data-ttu-id="77331-366">*扫描示例*</span><span class="sxs-lookup"><span data-stu-id="77331-366">*Example of scanning*</span></span>

<span data-ttu-id="77331-367">此扫描体验的性质可能因每个应用程序的需求而有很大差别，但两个主要原则应指导其设计。</span><span class="sxs-lookup"><span data-stu-id="77331-367">The nature of this scanning experience can vary greatly depending upon each application's needs, but two main principles should guide its design.</span></span>

<span data-ttu-id="77331-368">首先， **清除与用户的通信是主要关注** 点。</span><span class="sxs-lookup"><span data-stu-id="77331-368">Firstly, **clear communication with the user is the primary concern**.</span></span> <span data-ttu-id="77331-369">用户应始终知道是否满足应用程序的要求。</span><span class="sxs-lookup"><span data-stu-id="77331-369">The user should always be aware of whether the application's requirements are being met.</span></span> <span data-ttu-id="77331-370">当他们不能得到满足时，应立即向用户清楚地说明这是如此，并且应迅速采取适当的措施。</span><span class="sxs-lookup"><span data-stu-id="77331-370">When they aren't being met, it should be immediately clear to the user why this is so and they should be quickly led to take the appropriate action.</span></span>

<span data-ttu-id="77331-371">其次， **应用程序应尝试在效率和可靠性之间取得平衡**。</span><span class="sxs-lookup"><span data-stu-id="77331-371">Secondly, **applications should attempt to strike a balance between efficiency and reliability**.</span></span> <span data-ttu-id="77331-372">如果可以 **可靠地** 执行此操作，则应用程序应自动分析空间映射数据以节省用户时间。</span><span class="sxs-lookup"><span data-stu-id="77331-372">When it's possible to do so **reliably**, applications should automatically analyze spatial mapping data to save the user time.</span></span> <span data-ttu-id="77331-373">如果无法可靠地执行此操作，则应用程序应改为允许用户使用其所需的其他信息快速提供应用程序。</span><span class="sxs-lookup"><span data-stu-id="77331-373">When it isn't possible to do so reliably, applications should instead enable the user to quickly provide the application with the additional information it requires.</span></span>

<span data-ttu-id="77331-374">若要帮助设计正确的扫描体验，请考虑以下哪些可能适用于你的应用程序：</span><span class="sxs-lookup"><span data-stu-id="77331-374">To help design the right scanning experience, consider which of the following possibilities are applicable to your application:</span></span>

* <span data-ttu-id="77331-375">**无扫描体验**</span><span class="sxs-lookup"><span data-stu-id="77331-375">**No scanning experience**</span></span>
   * <span data-ttu-id="77331-376">如果没有任何引导式扫描体验，应用程序可以正常工作;它将了解在自然用户移动过程中观察到的图面。</span><span class="sxs-lookup"><span data-stu-id="77331-376">An application may function perfectly without any guided scanning experience; it will learn about surfaces that are observed in the course of natural user movement.</span></span>
   * <span data-ttu-id="77331-377">例如，允许用户在带有全息喷涂画图的表面上绘图的应用程序只需要知道当前对用户可见的表面。</span><span class="sxs-lookup"><span data-stu-id="77331-377">For example, an application that lets the user draw on surfaces with holographic spray paint requires knowledge only of the surfaces currently visible to the user.</span></span>
   * <span data-ttu-id="77331-378">如果环境中的用户已使用 HoloLens 花费了大量时间，则可能会扫描该环境。</span><span class="sxs-lookup"><span data-stu-id="77331-378">The environment may be scanned already if it's one in which the user has already spent lots of time using the HoloLens.</span></span>
   * <span data-ttu-id="77331-379">请记住，空间映射使用的相机只能在用户前面看到 3.1 m，因此，空间映射不会知道任何更远的图面，除非用户在过去从更远的距离观察到它们。</span><span class="sxs-lookup"><span data-stu-id="77331-379">Bear in mind however that the camera used by spatial mapping can only see 3.1 m in front of the user, so spatial mapping won't know about any more distant surfaces unless the user has observed them from a closer distance in the past.</span></span>
   * <span data-ttu-id="77331-380">因此，用户了解已经扫描了哪些表面，应用程序应提供此效果的视觉反馈，例如，将虚拟阴影转换到扫描图面上可能会帮助用户在这些表面上放置全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-380">So the user understands which surfaces have been scanned, the application should provide visual feedback to this effect, for example casting virtual shadows onto scanned surfaces may help the user place holograms on those surfaces.</span></span>
   * <span data-ttu-id="77331-381">在这种情况下，空间图面观察程序边界卷应更新为正文锁定的空间 [坐标系](coordinate-systems.md)，以便它们跟随用户。</span><span class="sxs-lookup"><span data-stu-id="77331-381">For this case, the spatial surface observer's bounding volumes should be updated each frame to a body-locked [spatial coordinate system](coordinate-systems.md), so that they follow the user.</span></span>

* <span data-ttu-id="77331-382">**查找合适的位置**</span><span class="sxs-lookup"><span data-stu-id="77331-382">**Find a suitable location**</span></span>
   * <span data-ttu-id="77331-383">应用程序可能设计为在具有特定要求的位置使用。</span><span class="sxs-lookup"><span data-stu-id="77331-383">An application may be designed for use in a location with specific requirements.</span></span>
   * <span data-ttu-id="77331-384">例如，应用程序可能需要用户周围的空白区域，以便他们可以安全地练习全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-384">For example, the application may require an empty area around the user so they can safely practice holographic kung-fu.</span></span>
   * <span data-ttu-id="77331-385">应用程序应会向用户传达任何特定的要求，并借助明确的视觉反馈来强化这些要求。</span><span class="sxs-lookup"><span data-stu-id="77331-385">Applications should communicate any specific requirements to the user up-front, and reinforce them with clear visual feedback.</span></span>
   * <span data-ttu-id="77331-386">此示例中，应用程序应可视化所需空白区域的范围，并直观地突出显示此区域中是否存在任何不需要的对象。</span><span class="sxs-lookup"><span data-stu-id="77331-386">In this example, the application should visualize the extent of the required empty area and visually highlight the presence of any undesired objects within this zone.</span></span>
   * <span data-ttu-id="77331-387">在这种情况下，空间图面观察器边界卷应在所选位置使用世界锁定的空间坐标系。 [](coordinate-systems.md)</span><span class="sxs-lookup"><span data-stu-id="77331-387">For this case, the spatial surface observer's bounding volumes should use a world-locked [spatial coordinate system](coordinate-systems.md) in the chosen location.</span></span>

* <span data-ttu-id="77331-388">**查找合适的图面配置**</span><span class="sxs-lookup"><span data-stu-id="77331-388">**Find a suitable configuration of surfaces**</span></span>
   * <span data-ttu-id="77331-389">应用程序可能需要特定的表面配置，例如两个大型的平墙，以创建一个镜像全息门面。</span><span class="sxs-lookup"><span data-stu-id="77331-389">An application may require a specific configuration of surfaces, for example two large, flat, opposing walls to create a holographic hall of mirrors.</span></span>
   * <span data-ttu-id="77331-390">在这种情况下，应用程序需要分析空间映射提供的表面以检测合适的表面，并引导用户指向它们。</span><span class="sxs-lookup"><span data-stu-id="77331-390">In such cases, the application will need to analyze the surfaces provided by spatial mapping to detect suitable surfaces, and direct the user toward them.</span></span>
   * <span data-ttu-id="77331-391">如果应用程序的图面分析不可靠，用户应具有回退选项。</span><span class="sxs-lookup"><span data-stu-id="77331-391">The user should have a fallback option if the application's surface analysis isn't reliable.</span></span> <span data-ttu-id="77331-392">例如，如果应用程序错误地将门道标识为平墙，则用户需要一种简单的方式来更正此错误。</span><span class="sxs-lookup"><span data-stu-id="77331-392">For example, if the application incorrectly identifies a doorway as a flat wall, the user needs a simple way to correct this error.</span></span>

* <span data-ttu-id="77331-393">**扫描部分环境**</span><span class="sxs-lookup"><span data-stu-id="77331-393">**Scan part of the environment**</span></span>
   * <span data-ttu-id="77331-394">应用程序可能只希望按用户指示捕获环境的一部分。</span><span class="sxs-lookup"><span data-stu-id="77331-394">An application may wish to only capture part of the environment, as directed by the user.</span></span>
   * <span data-ttu-id="77331-395">例如，应用程序会扫描房间的一部分，以便用户可以发布全息分类广告，寻找想要销售的餐厅。</span><span class="sxs-lookup"><span data-stu-id="77331-395">For example, the application scans part of a room so the user may post a holographic classified ad for furniture they wish to sell.</span></span>
   * <span data-ttu-id="77331-396">在这种情况下，应用程序应捕获用户在扫描期间观察到的区域的空间映射数据。</span><span class="sxs-lookup"><span data-stu-id="77331-396">In this case, the application should capture spatial mapping data within the regions observed by the user during their scan.</span></span>

* <span data-ttu-id="77331-397">**扫描整个房间**</span><span class="sxs-lookup"><span data-stu-id="77331-397">**Scan the whole room**</span></span>
   * <span data-ttu-id="77331-398">应用程序可能需要扫描当前房间的所有表面，包括用户后面的表面。</span><span class="sxs-lookup"><span data-stu-id="77331-398">An application may require a scan of all of the surfaces in the current room, including those behind the user.</span></span>
   * <span data-ttu-id="77331-399">例如，游戏可能将用户作为 Gulliver 的角色，在 siege 中，从数百个微小 Lilliputians 接近所有方向。</span><span class="sxs-lookup"><span data-stu-id="77331-399">For example, a game may put the user in the role of Gulliver, under siege from hundreds of tiny Lilliputians approaching from all directions.</span></span>
   * <span data-ttu-id="77331-400">在这种情况下，应用程序需要确定当前房间中已经扫描了多少个面，并指示用户的注视填充了重大间隙。</span><span class="sxs-lookup"><span data-stu-id="77331-400">In such cases, the application will need to determine how many of the surfaces in the current room have already been scanned, and direct the user's gaze to fill in significant gaps.</span></span>
   * <span data-ttu-id="77331-401">此过程的关键是提供可视反馈，使用户清楚地知道尚未扫描哪些表面。</span><span class="sxs-lookup"><span data-stu-id="77331-401">The key to this process is providing visual feedback that makes it clear to the user which surfaces haven't yet been scanned.</span></span> <span data-ttu-id="77331-402">例如，应用程序可以使用 [基于距离的雾化](/windows/win32/direct3d9/fog-formulas) 来以可视方式突出显示空间映射图面未涵盖的区域。</span><span class="sxs-lookup"><span data-stu-id="77331-402">The application could, for example,  use [distance-based fog](/windows/win32/direct3d9/fog-formulas) to visually highlight regions that aren't covered by spatial mapping surfaces.</span></span>

* <span data-ttu-id="77331-403">**获取环境的初始快照**</span><span class="sxs-lookup"><span data-stu-id="77331-403">**Take an initial snapshot of the environment**</span></span>
   * <span data-ttu-id="77331-404">在采用初始 "快照" 后，应用程序可能希望忽略环境中的所有更改。</span><span class="sxs-lookup"><span data-stu-id="77331-404">An application may wish to ignore all changes in the environment after taking an initial 'snapshot'.</span></span>
   * <span data-ttu-id="77331-405">这可能适用于避免与环境中的初始状态紧密耦合的用户创建数据的中断。</span><span class="sxs-lookup"><span data-stu-id="77331-405">This may be appropriate to avoid disruption of user-created data that is tightly coupled to the initial state of the environment.</span></span>
   * <span data-ttu-id="77331-406">在这种情况下，在扫描完成后，应用程序应在其初始状态下生成空间映射数据的副本。</span><span class="sxs-lookup"><span data-stu-id="77331-406">In this case, the application should make a copy of the spatial mapping data in its initial state once the scan is complete.</span></span>
   * <span data-ttu-id="77331-407">如果在环境中仍有封闭像素，则应用程序应继续接收空间映射数据的更新。</span><span class="sxs-lookup"><span data-stu-id="77331-407">Applications should continue receiving updates to spatial mapping data if holograms are still to be correctly occluded by the environment.</span></span>
   * <span data-ttu-id="77331-408">对于空间映射数据的持续更新，还允许对已发生的任何更改进行可视化，并向用户阐明环境以前和当前状态之间的差异。</span><span class="sxs-lookup"><span data-stu-id="77331-408">Continued updates to spatial mapping data also allow visualizing any changes that have occurred, clarifying to the user the differences between prior and present states of the environment.</span></span>

* <span data-ttu-id="77331-409">**采用用户启动的环境快照**</span><span class="sxs-lookup"><span data-stu-id="77331-409">**Take user-initiated snapshots of the environment**</span></span>
   * <span data-ttu-id="77331-410">应用程序可能只希望在用户指示时对环境更改做出响应。</span><span class="sxs-lookup"><span data-stu-id="77331-410">An application may only wish to respond to environmental changes when instructed by the user.</span></span>
   * <span data-ttu-id="77331-411">例如，用户可以通过在不同时刻捕获其姿势来创建多个 3D "statues"。</span><span class="sxs-lookup"><span data-stu-id="77331-411">For example, the user could create multiple 3D 'statues' of a friend by capturing their poses at different moments.</span></span>

* <span data-ttu-id="77331-412">**允许用户更改环境**</span><span class="sxs-lookup"><span data-stu-id="77331-412">**Allow the user to change the environment**</span></span>
   * <span data-ttu-id="77331-413">应用程序可用于实时响应用户环境中所做的任何更改。</span><span class="sxs-lookup"><span data-stu-id="77331-413">An application may be designed to respond in real time to any changes made in the user's environment.</span></span>
   * <span data-ttu-id="77331-414">例如，如果在另一侧发生全息部游戏，则用户绘制窗帘可能会触发 "场景变化"。</span><span class="sxs-lookup"><span data-stu-id="77331-414">For example, the user drawing a curtain could trigger 'scene change' for a holographic play taking place on the other side.</span></span>

* <span data-ttu-id="77331-415">**指导用户避免空间映射数据中的错误**</span><span class="sxs-lookup"><span data-stu-id="77331-415">**Guide the user to avoid errors in the spatial mapping data**</span></span>
   * <span data-ttu-id="77331-416">应用程序可能需要在用户扫描其环境时为用户提供指导。</span><span class="sxs-lookup"><span data-stu-id="77331-416">An application may wish to provide guidance to the user while they're scanning their environment.</span></span>
   * <span data-ttu-id="77331-417">这可以帮助用户避免空间映射数据中的某些类型的错误[](spatial-mapping.md#what-influences-spatial-mapping-quality)，例如，避免使用日照窗口或镜像。</span><span class="sxs-lookup"><span data-stu-id="77331-417">This can help the user to avoid certain kinds of [errors in the spatial mapping data](spatial-mapping.md#what-influences-spatial-mapping-quality), for example by staying away from sunlit windows or mirrors.</span></span>

<span data-ttu-id="77331-418">要注意的一个额外详细信息是空间映射数据的"范围"不是无限的。</span><span class="sxs-lookup"><span data-stu-id="77331-418">One extra detail to be aware of is that the 'range' of spatial mapping data isn't unlimited.</span></span> <span data-ttu-id="77331-419">虽然空间映射确实会构建一个包含大型空间的永久数据库，但它仅使数据可供用户周围大小有限的"气泡"中的应用程序使用。</span><span class="sxs-lookup"><span data-stu-id="77331-419">While spatial mapping does build a permanent database of large spaces, it only makes that data available to applications in a 'bubble' of limited size around the user.</span></span> <span data-ttu-id="77331-420">如果从长云的开头开始，距离起点足够远，则最终，起点处的空间图面将消失。</span><span class="sxs-lookup"><span data-stu-id="77331-420">If you start at the beginning of a long corridor and walk far enough away from the start, then eventually the spatial surfaces back at the beginning will disappear.</span></span> <span data-ttu-id="77331-421">可以在这些图面从可用空间映射数据中消失后，在应用程序中缓存这些图面，从而缓解这种情况。</span><span class="sxs-lookup"><span data-stu-id="77331-421">You can mitigate this by caching those surfaces in your application after they've disappeared from the available spatial mapping data.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="77331-422">网格处理</span><span class="sxs-lookup"><span data-stu-id="77331-422">Mesh processing</span></span>

<span data-ttu-id="77331-423">它可以帮助检测图面中的常见错误类型，并根据需要筛选、删除或修改空间映射数据。</span><span class="sxs-lookup"><span data-stu-id="77331-423">It may help to detect common types of errors in surfaces and to filter, remove or modify the spatial mapping data as appropriate.</span></span>

<span data-ttu-id="77331-424">请记住，空间映射数据旨在尽可能真实地应用于实际表面，因此，应用的任何处理都可能会将表面从"真实"中进一步转移。</span><span class="sxs-lookup"><span data-stu-id="77331-424">Bear in mind that spatial mapping data is intended to be as faithful as possible to real-world surfaces, so any processing you apply risks shifting your surfaces further from the 'truth'.</span></span>

<span data-ttu-id="77331-425">下面是一些可能有用的不同类型的网格处理示例：</span><span class="sxs-lookup"><span data-stu-id="77331-425">Here are some examples of different types of mesh processing that you may find useful:</span></span>

* <span data-ttu-id="77331-426">**孔填充**</span><span class="sxs-lookup"><span data-stu-id="77331-426">**Hole filling**</span></span>
   * <span data-ttu-id="77331-427">如果由深色材料制造的小对象无法扫描，它将在周围的表面留下一个孔。</span><span class="sxs-lookup"><span data-stu-id="77331-427">If a small object made of a dark material fails to scan, it will leave a hole in the surrounding surface.</span></span>
   * <span data-ttu-id="77331-428">孔会影响遮挡：全息影像可以在假定不透明的真实表面"穿过"一个孔。</span><span class="sxs-lookup"><span data-stu-id="77331-428">Holes affect occlusion: holograms can be seen 'through' a hole in a supposedly opaque real-world surface.</span></span>
   * <span data-ttu-id="77331-429">孔会影响光线广播：如果使用光线广播来帮助用户与表面交互，则这些射线可能不需要通过孔。</span><span class="sxs-lookup"><span data-stu-id="77331-429">Holes affect raycasts: if you're using raycasts to help users interact with surfaces, it may be undesirable for these rays to pass through holes.</span></span> <span data-ttu-id="77331-430">一种缓解措施是使用涵盖适当大小的区域的多个光线广播捆绑包。</span><span class="sxs-lookup"><span data-stu-id="77331-430">One mitigation is to use a bundle of multiple raycasts covering an appropriately sized region.</span></span> <span data-ttu-id="77331-431">这样，你可筛选"离群值"结果，以便即使一个光线广播通过小孔，聚合结果仍将有效。</span><span class="sxs-lookup"><span data-stu-id="77331-431">This will allow you to filter 'outlier' results, so that even if one raycast passes through a small hole, the aggregate result will still be valid.</span></span> <span data-ttu-id="77331-432">但是，此方法需要计算成本。</span><span class="sxs-lookup"><span data-stu-id="77331-432">However, this approach comes at a computational cost.</span></span>
   * <span data-ttu-id="77331-433">孔洞会影响物理学冲突：物理学模拟控制的对象可能会贯穿地面的孔，并会丢失。</span><span class="sxs-lookup"><span data-stu-id="77331-433">Holes affect physics collisions: an object controlled by physics simulation may drop through a hole in the floor and become lost.</span></span>
   * <span data-ttu-id="77331-434">可以算法在 surface 网格中填充此类孔。</span><span class="sxs-lookup"><span data-stu-id="77331-434">It's possible to algorithmically fill such holes in the surface mesh.</span></span> <span data-ttu-id="77331-435">但是，你需要调整算法，以便不会填充 "real" （如 windows 和两侧）。</span><span class="sxs-lookup"><span data-stu-id="77331-435">However, you'll need to tune your algorithm so that 'real holes' such as windows and doorways don't get filled in.</span></span> <span data-ttu-id="77331-436">可能很难可靠地区分 "真实漏洞" 和 "虚部"，因此需要尝试不同的试探法，如 "大小" 和 "边界形状"。</span><span class="sxs-lookup"><span data-stu-id="77331-436">It can be difficult to reliably differentiate 'real holes' from 'imaginary holes', so you'll need to experiment with different heuristics such as 'size' and 'boundary shape'.</span></span>

* <span data-ttu-id="77331-437">**删除 Hallucination**</span><span class="sxs-lookup"><span data-stu-id="77331-437">**Hallucination removal**</span></span>
   * <span data-ttu-id="77331-438">反射、明亮灯光和移动对象可能会使小延迟 "hallucinations" 浮动在中。</span><span class="sxs-lookup"><span data-stu-id="77331-438">Reflections, bright lights, and moving objects can leave small lingering 'hallucinations' floating in mid-air.</span></span>
   * <span data-ttu-id="77331-439">Hallucinations 影响封闭： Hallucinations 可能会成为深色形状，并将其移到上，并 occluding 其他全息影像。</span><span class="sxs-lookup"><span data-stu-id="77331-439">Hallucinations affect occlusion: hallucinations may become visible as dark shapes moving in front of and occluding other holograms.</span></span>
   * <span data-ttu-id="77331-440">Hallucinations 影响 raycasts：如果你使用 raycasts 帮助用户与表面交互，则这些光线可能会碰到 hallucination，而不是其背后的表面。</span><span class="sxs-lookup"><span data-stu-id="77331-440">Hallucinations affect raycasts: if you're using raycasts to help users interact with surfaces, these rays could hit a hallucination instead of the surface behind it.</span></span> <span data-ttu-id="77331-441">与孔洞一样，一种缓解措施是使用许多 raycasts，而不是使用单个 raycast，但这会产生计算成本。</span><span class="sxs-lookup"><span data-stu-id="77331-441">As with holes, one mitigation is to use many raycasts instead of a single raycast, but again this will come at a computational cost.</span></span>
   * <span data-ttu-id="77331-442">Hallucinations 影响物理学冲突：物理学模拟控制的对象可能会停滞在 hallucination 的位置，并且无法在看似清晰的空间区域中移动。</span><span class="sxs-lookup"><span data-stu-id="77331-442">Hallucinations affect physics collisions: an object controlled by physics simulation may become stuck against a hallucination and be unable to move through a seemingly clear area of space.</span></span>
   * <span data-ttu-id="77331-443">可以从 surface 网格筛选此类 hallucinations。</span><span class="sxs-lookup"><span data-stu-id="77331-443">It's possible to filter such hallucinations from the surface mesh.</span></span> <span data-ttu-id="77331-444">但是，与孔洞一样，你需要调整算法，使真实的小对象（如灯具和门控点）不会被删除。</span><span class="sxs-lookup"><span data-stu-id="77331-444">However, as with holes, you'll need to tune your algorithm so that real small objects such as lamp-stands and door handles don't get removed.</span></span>

* <span data-ttu-id="77331-445">**光滑**</span><span class="sxs-lookup"><span data-stu-id="77331-445">**Smoothing**</span></span>
   * <span data-ttu-id="77331-446">空间映射可能会返回与实际对应项相比显得非常粗糙或 "干扰" 的表面。</span><span class="sxs-lookup"><span data-stu-id="77331-446">Spatial mapping may return surfaces that appear to be rough or 'noisy' in comparison to their real-world counterparts.</span></span>
   * <span data-ttu-id="77331-447">平滑度会影响物理学冲突：如果地面为粗糙，则物理模拟的高尔夫球可能不会以直线平滑地滚动。</span><span class="sxs-lookup"><span data-stu-id="77331-447">Smoothness affects physics collisions: if the floor is rough, a physically simulated golf ball may not roll smoothly across it in a straight line.</span></span>
   * <span data-ttu-id="77331-448">平滑度会影响呈现：如果图面直接可视化，则视觉表面的法线会影响其外观并干扰 "干净" 的外观。</span><span class="sxs-lookup"><span data-stu-id="77331-448">Smoothness affects rendering: if a surface is visualized directly, rough surface normals can affect its appearance and disrupt a 'clean' look.</span></span> <span data-ttu-id="77331-449">可以通过使用着色器中用于呈现图面的适当照明和纹理来缓解这种情况。</span><span class="sxs-lookup"><span data-stu-id="77331-449">It's possible to mitigate this by using appropriate lighting and textures in the shader that is used to render the surface.</span></span>
   * <span data-ttu-id="77331-450">可以平滑处理表面网格中的粗糙度。</span><span class="sxs-lookup"><span data-stu-id="77331-450">It's possible to smooth out roughness in a surface mesh.</span></span> <span data-ttu-id="77331-451">但是，这可能会进一步将表面推离相应的实际表面。</span><span class="sxs-lookup"><span data-stu-id="77331-451">However, this may push the surface further away from the corresponding real-world surface.</span></span> <span data-ttu-id="77331-452">保持紧密对应对于生成准确的全息影像遮挡以及使用户能够实现与全息图面的精确且可预测的交互非常重要。</span><span class="sxs-lookup"><span data-stu-id="77331-452">Maintaining a close correspondence is important to produce accurate hologram occlusion, and to enable users to achieve precise and predictable interactions with holographic surfaces.</span></span>
   * <span data-ttu-id="77331-453">如果只需要修饰更改，则无需更改顶点位置即可平滑顶点法线。</span><span class="sxs-lookup"><span data-stu-id="77331-453">If only a cosmetic change is required, it may be sufficient to smooth vertex normals without changing vertex positions.</span></span>

* <span data-ttu-id="77331-454">**平面查找**</span><span class="sxs-lookup"><span data-stu-id="77331-454">**Plane finding**</span></span>
   * <span data-ttu-id="77331-455">应用程序可能希望对空间映射提供的图面执行许多形式的分析。</span><span class="sxs-lookup"><span data-stu-id="77331-455">There are many forms of analysis that an application may wish to perform on the surfaces provided by spatial mapping.</span></span>
   * <span data-ttu-id="77331-456">一个简单的示例是"平面查找";标识边界，主要是平面图面区域。</span><span class="sxs-lookup"><span data-stu-id="77331-456">One simple example is 'plane finding'; identifying bounded, mostly planar regions of surfaces.</span></span>
   * <span data-ttu-id="77331-457">平面区域可以用作全息工作图面，应用程序可以自动放置全息内容的区域。</span><span class="sxs-lookup"><span data-stu-id="77331-457">Planar regions can be used as holographic work-surfaces, regions where holographic content can be automatically placed by the application.</span></span>
   * <span data-ttu-id="77331-458">平面区域可以约束用户界面，以指导用户与最适合其需求的图面进行交互。</span><span class="sxs-lookup"><span data-stu-id="77331-458">Planar regions can constrain the user interface, to guide users to interact with the surfaces that best suit their needs.</span></span>
   * <span data-ttu-id="77331-459">平面区域可以像在现实世界中一样用于与功能对象（如LCC 屏幕、表或白板）对应的全息区域。</span><span class="sxs-lookup"><span data-stu-id="77331-459">Planar regions can be used as in the real world, for holographic counterparts to functional objects such as LCD screens, tables or whiteboards.</span></span>
   * <span data-ttu-id="77331-460">平面区域可以定义播放区域，构成游戏级别的基础。</span><span class="sxs-lookup"><span data-stu-id="77331-460">Planar regions can define play areas, forming the basis of video game levels.</span></span>
   * <span data-ttu-id="77331-461">平面区域可以通过识别实际人员可能穿过的楼层区域，帮助虚拟代理在现实世界中导航。</span><span class="sxs-lookup"><span data-stu-id="77331-461">Planar regions can aid virtual agents to navigate the real world, by identifying the areas of floor that real people are likely to walk on.</span></span>

## <a name="prototyping-and-debugging"></a><span data-ttu-id="77331-462">原型制作和调试</span><span class="sxs-lookup"><span data-stu-id="77331-462">Prototyping and debugging</span></span>

### <a name="useful-tools"></a><span data-ttu-id="77331-463">有用工具</span><span class="sxs-lookup"><span data-stu-id="77331-463">Useful tools</span></span>

* <span data-ttu-id="77331-464">[HoloLens 仿真](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md)器可用于开发使用空间映射的应用程序，而无需访问物理 HoloLens。</span><span class="sxs-lookup"><span data-stu-id="77331-464">The [HoloLens emulator](../develop/platform-capabilities-and-apis/using-the-hololens-emulator.md) can be used to develop applications using spatial mapping without access to a physical HoloLens.</span></span> <span data-ttu-id="77331-465">它允许你在真实的环境中模拟 HoloLens 上的实时会话，以及应用程序通常使用的所有数据，包括 HoloLens 运动、空间坐标系和空间映射网格。</span><span class="sxs-lookup"><span data-stu-id="77331-465">It allows you to simulate a live session on a HoloLens in a realistic environment, with all of the data your application would normally consume, including HoloLens motion, spatial coordinate systems, and spatial mapping meshes.</span></span> <span data-ttu-id="77331-466">这可用于提供可靠、可重复的输入，这可用于调试问题和评估对代码的更改。</span><span class="sxs-lookup"><span data-stu-id="77331-466">This can be used to provide reliable, repeatable input, which can be useful for debugging problems and evaluating changes to your code.</span></span>
* <span data-ttu-id="77331-467">若要重现方案，请从实时 HoloLens 捕获网络的空间映射数据，然后将数据保存到磁盘，并在稍后的调试会话中重复使用。</span><span class="sxs-lookup"><span data-stu-id="77331-467">To reproduce a scenario, capture spatial mapping data over the network from a live HoloLens, then save it to disk and reuse it in later debugging sessions.</span></span>
* <span data-ttu-id="77331-468">[Windows 设备门户三维视图](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view)提供了一种方法，用于查看当前通过空间映射系统提供的所有空间图面。</span><span class="sxs-lookup"><span data-stu-id="77331-468">The [Windows device portal 3D view](../develop/platform-capabilities-and-apis/using-the-windows-device-portal.md#3d-view) provides a way to see all of the spatial surfaces currently available via the spatial mapping system.</span></span> <span data-ttu-id="77331-469">这为应用程序内的空间曲面提供了比较基础;例如，您可以很容易地判断是否有任何空间图面丢失或显示在错误的位置。</span><span class="sxs-lookup"><span data-stu-id="77331-469">This provides a basis of comparison for the spatial surfaces inside your application; for example, you can easily tell if any spatial surfaces are missing or are being displayed in the wrong place.</span></span>

### <a name="general-prototyping-guidance"></a><span data-ttu-id="77331-470">一般原型设计指南</span><span class="sxs-lookup"><span data-stu-id="77331-470">General prototyping guidance</span></span>

* <span data-ttu-id="77331-471">由于空间映射数据中的 [错误](spatial-mapping.md#what-influences-spatial-mapping-quality) 可能会对用户体验造成很大的影响，因此建议在各种环境中测试应用程序。</span><span class="sxs-lookup"><span data-stu-id="77331-471">Because [errors](spatial-mapping.md#what-influences-spatial-mapping-quality) in the spatial mapping data may strongly affect your user's experience, we recommend that you test your application in a wide variety of environments.</span></span>
* <span data-ttu-id="77331-472">不要以始终在同一位置（例如在办公桌）上进行测试的习惯进行捕获。</span><span class="sxs-lookup"><span data-stu-id="77331-472">Don't get trapped in the habit of always testing in the same location, for example at your desk.</span></span> <span data-ttu-id="77331-473">请确保在不同位置、形状、大小和材料的各种曲面上进行测试。</span><span class="sxs-lookup"><span data-stu-id="77331-473">Make sure to test on various surfaces of different positions, shapes, sizes, and materials.</span></span>
* <span data-ttu-id="77331-474">同样，尽管综合数据或记录的数据对于调试非常有用，但不太依赖于相同的几个测试用例。</span><span class="sxs-lookup"><span data-stu-id="77331-474">Similarly, while synthetic or recorded data can be useful for debugging, don't become too reliant upon the same few test cases.</span></span> <span data-ttu-id="77331-475">这可能会延迟查找更多测试会提前捕获的重要问题。</span><span class="sxs-lookup"><span data-stu-id="77331-475">This may delay finding important issues that more varied testing would have caught earlier.</span></span>
* <span data-ttu-id="77331-476">使用真实 (和理想的 uncoached) 用户进行测试是一个不错的做法，因为它们不能使用 HoloLens 或您的应用程序的方式与您的应用程序完全相同。</span><span class="sxs-lookup"><span data-stu-id="77331-476">It's a good idea to perform testing with real (and ideally uncoached) users, because they may not use the HoloLens or your application in exactly the same way that you do.</span></span> <span data-ttu-id="77331-477">事实上，这可能会让您感到他人的行为、知识和假设有多多。</span><span class="sxs-lookup"><span data-stu-id="77331-477">In fact, it may surprise you how divergent people's behavior, knowledge, and assumptions can be!</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="77331-478">疑难解答</span><span class="sxs-lookup"><span data-stu-id="77331-478">Troubleshooting</span></span>

* <span data-ttu-id="77331-479">为了正确地面向 surface 网格，每个 GameObject 都需要处于活动状态，然后才能将其发送到 SurfaceObserver 来构造其网格。</span><span class="sxs-lookup"><span data-stu-id="77331-479">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it's sent to the SurfaceObserver to have its mesh constructed.</span></span> <span data-ttu-id="77331-480">否则，网格将显示在您的空间中，但会旋转为古怪度。</span><span class="sxs-lookup"><span data-stu-id="77331-480">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="77331-481">需要将运行与 SurfaceObserver 通信的脚本的 GameObject 设置为源。</span><span class="sxs-lookup"><span data-stu-id="77331-481">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="77331-482">否则，你创建并发送到 SurfaceObserver 的所有 Gameobject 都具有与父游戏对象的偏移量相等的偏移量。</span><span class="sxs-lookup"><span data-stu-id="77331-482">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="77331-483">这会使你的网格显示多个米，这使得调试正在进行的操作变得很困难。</span><span class="sxs-lookup"><span data-stu-id="77331-483">This can make your meshes show up several meters away, which makes it hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="77331-484">另请参阅</span><span class="sxs-lookup"><span data-stu-id="77331-484">See also</span></span>

* [<span data-ttu-id="77331-485">坐标系统</span><span class="sxs-lookup"><span data-stu-id="77331-485">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="77331-486">DirectX 中的空间映射</span><span class="sxs-lookup"><span data-stu-id="77331-486">Spatial mapping in DirectX</span></span>](../develop/native/spatial-mapping-in-directx.md)
* [<span data-ttu-id="77331-487">Unity 中的空间映射</span><span class="sxs-lookup"><span data-stu-id="77331-487">Spatial mapping in Unity</span></span>](../develop/unity/spatial-mapping-in-unity.md)
* [<span data-ttu-id="77331-488">场景理解</span><span class="sxs-lookup"><span data-stu-id="77331-488">Scene Understanding</span></span>](scene-understanding.md)
* [<span data-ttu-id="77331-489">房间扫描可视化</span><span class="sxs-lookup"><span data-stu-id="77331-489">Room scan visualization</span></span>](room-scan-visualization.md)
* [<span data-ttu-id="77331-490">空间音效设计</span><span class="sxs-lookup"><span data-stu-id="77331-490">Spatial sound design</span></span>](spatial-sound-design.md)
* [<span data-ttu-id="77331-491">案例研究 - 看透现实中的洞</span><span class="sxs-lookup"><span data-stu-id="77331-491">Case study - Looking through holes in your reality</span></span>](../out-of-scope/case-study-looking-through-holes-in-your-reality.md)