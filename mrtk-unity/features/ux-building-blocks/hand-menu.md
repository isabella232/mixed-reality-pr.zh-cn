---
title: 手动菜单
description: MRTK 中的手形菜单示例场景
author: cre8ivepark
ms.author: dongpark
ms.date: 01/12/2021
keywords: Unity，HoloLens，HoloLens 2，Mixed Reality，开发，MRTK，HandMenu，
ms.openlocfilehash: 9bb0276c048912b4f463dd93d3303c9a3af8fe29
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/01/2021
ms.locfileid: "113177527"
---
# <a name="hand-menu"></a><span data-ttu-id="8f7ed-104">手动菜单</span><span class="sxs-lookup"><span data-stu-id="8f7ed-104">Hand menu</span></span>

![手动菜单 UX 示例](../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="8f7ed-106">手动菜单允许用户快速为常用函数获取手动连接的 UI。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-106">Hand menus allow users to quickly bring up hand-attached UI for frequently used functions.</span></span> <span data-ttu-id="8f7ed-107">若要防止在与其他对象交互时出现错误激活，则可以使用 "上" 菜单提供 "需要平头" 和 "使用注视激活" 等选项。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-107">To prevent false activation while interacting with other objects, hand menu provides options such as 'Require Flat Hand' and 'Use Gaze Activation'.</span></span> <span data-ttu-id="8f7ed-108">建议使用这些选项以防止不必要的激活。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-108">It is recommended to use these options to prevent unwanted activation.</span></span>

## <a name="hand-menu-examples"></a><span data-ttu-id="8f7ed-109">手动菜单示例</span><span class="sxs-lookup"><span data-stu-id="8f7ed-109">Hand menu examples</span></span>

<span data-ttu-id="8f7ed-110">**HandMenuExamples** 场景位于 ``MRTK/Examples/Demos/HandTracking/Scenes`` 文件夹下。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-110">**HandMenuExamples.unity** scene is under ``MRTK/Examples/Demos/HandTracking/Scenes`` folder.</span></span> <span data-ttu-id="8f7ed-111">当它运行时，场景将仅激活当前选定的菜单类型。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-111">When it is running, the scene will only activate currently selected menu type.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_ExampleScene.png" width="600px" alt="HandMenu_ExampleScene">

<span data-ttu-id="8f7ed-112">可以在 "文件夹" 下找到 prototyping ``MRTK/Examples/Demos/HandTracking/Prefabs`` 。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-112">You can find these hand menu prefabs under ``MRTK/Examples/Demos/HandTracking/Prefabs`` folder.</span></span>

### <a name="handmenu_small_hideonhanddrop-and-handmenu_medium_hideonhanddrop"></a><span data-ttu-id="8f7ed-113">HandMenu_Small_HideOnHandDrop 和 HandMenu_Medium_HideOnHandDrop</span><span class="sxs-lookup"><span data-stu-id="8f7ed-113">HandMenu_Small_HideOnHandDrop and HandMenu_Medium_HideOnHandDrop</span></span>

<span data-ttu-id="8f7ed-114">这两个示例只是激活和停用 MenuContent 对象，以便显示和隐藏 **OnFirstHandDetected ()** 和 **OnLastHandLost ()** 事件上的菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-114">These two examples simply activate and deactivate the MenuContent object to show and hide menu on **OnFirstHandDetected()** and **OnLastHandLost()** event.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example1.png" width="600" alt="HandMenu_ExampleScene 1">
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example2.png" width="600" alt="HandMenu_ExampleScene 2">

### <a name="handmenu_large_worldlock_on_grabandpull"></a><span data-ttu-id="8f7ed-115">HandMenu_Large_WorldLock_On_GrabAndPull</span><span class="sxs-lookup"><span data-stu-id="8f7ed-115">HandMenu_Large_WorldLock_On_GrabAndPull</span></span>

<span data-ttu-id="8f7ed-116">对于需要较长时间交互时间的更复杂菜单，建议使用全局锁定菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-116">For more complex menus that require longer interaction time, it is recommended to world-lock the menu.</span></span> <span data-ttu-id="8f7ed-117">在此示例中，除了激活和停用 **OnFirstHandDetected ()** 和 **OnLastHandLost ()** 事件外，用户还可以获取并拉取到全局锁定菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-117">In this example, the user can grab and pull to world-lock the menu, in addition to activating and deactivating the MenuContent on **OnFirstHandDetected()** and **OnLastHandLost()** events.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example3.png" width="600" alt="HandMenu_ExampleScene 3">

<span data-ttu-id="8f7ed-118">Backplate `ManipulationHandler` 使其 grabbable 并可移动。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-118">Backplate's `ManipulationHandler` makes it grabbable and movable.</span></span> <span data-ttu-id="8f7ed-119">**在操作已启动时** ， **SolverHandler UpdateSolvers** 被停用，使其成为全局锁定菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-119">**On Manipulation Started** event, **SolverHandler.UpdateSolvers** is deactivated to world-lock the menu.</span></span> <span data-ttu-id="8f7ed-120">此外，它还会显示 " **关闭" 按钮** ，以允许用户在任务完成时关闭菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-120">Additionally, it shows the **Close button** to allow the user to close the menu when the task is finished.</span></span> <span data-ttu-id="8f7ed-121">**处理结束事件时** ，它会调用 **HandConstraintPalmUp** ，以允许用户通过引发和查看 palm 来返回菜单。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-121">**On Manipulation Ended** event, it calls **HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine** to allow the user bring the menu back to hand by raising and looking at the palm.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example4.png" width="600" alt="HandMenu_ExampleScene 4">

<span data-ttu-id="8f7ed-122">"**关闭**" 按钮会重新激活 **SolverHandler UpdateSolvers** 并隐藏 **MenuContent**。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-122">**Close** button reactivates **SolverHandler.UpdateSolvers** and hide the **MenuContent**.</span></span>
<br/><img src="../images/hand-menu/MRTK_HandMenu_Example5.png" alt="HandMenu_ExampleScene 5">

### <a name="handmenu_large_autoworldlock_on_handdrop"></a><span data-ttu-id="8f7ed-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span><span class="sxs-lookup"><span data-stu-id="8f7ed-123">HandMenu_Large_AutoWorldLock_On_HandDrop</span></span>

<span data-ttu-id="8f7ed-124">此示例类似于 HandMenu_Large_WorldLock_On_GrabAndPull。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-124">This example is similar to HandMenu_Large_WorldLock_On_GrabAndPull.</span></span> <span data-ttu-id="8f7ed-125">唯一的区别是，菜单将自动放置时自动锁定。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-125">The only difference is that the menu will be automatically world-locked on hand drop.</span></span> <span data-ttu-id="8f7ed-126">只需隐藏 **OnLastHandLost ()** 事件上的 MenuContent 即可完成此操作。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-126">This is done by simply not hiding the MenuContent on **OnLastHandLost()** event.</span></span> <span data-ttu-id="8f7ed-127">抓取 & 拉取行为与 HandMenu_Large_WorldLock_On_GrabAndPull 示例相同。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-127">Grab & pull behavior is same as HandMenu_Large_WorldLock_On_GrabAndPull example.</span></span>

## <a name="scripts"></a><span data-ttu-id="8f7ed-128">脚本</span><span class="sxs-lookup"><span data-stu-id="8f7ed-128">Scripts</span></span>

<span data-ttu-id="8f7ed-129">此 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 行为提供了一个求解器，用于将跟踪的对象约束为适用于手写 (的区域，如手写用户 UI、菜单等) 。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-129">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="8f7ed-130">保险箱区域被视为不与手相交的区域。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-130">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="8f7ed-131">还包含一个名为的派生类， [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 以演示当 palm 面向用户时激活规划求解跟踪对象的常见行为。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-131">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="8f7ed-132">有关其他文档，请参阅可用于每个属性的工具提示 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-132">Please see the tool tips available for each [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) property for additional documentation.</span></span> <span data-ttu-id="8f7ed-133">下面更详细地定义了几个属性。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-133">A few properties are defined in more detail below.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintPalmUp.png" width="450" alt="HandMenu_ExampleScene Palm up">

* <span data-ttu-id="8f7ed-134">**保险箱区域**：安全区域指定对内容进行约束的位置。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-134">**Safe Zone**: The safe zone specifies where on the hand to constrain content.</span></span> <span data-ttu-id="8f7ed-135">建议将内容放在 Ulnar 端，以避免与手和改善交互质量重叠。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-135">It is recommended that content be placed on the Ulnar Side to avoid overlap with the hand and improved interaction quality.</span></span> <span data-ttu-id="8f7ed-136">保险箱区域的计算方法是：将双手方向投影到与相机的视图相对应的平面中，并 raycasting。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-136">Safe zones are calculated by taking the hands orientation projected into a plane orthogonal to the camera's view and raycasting against a bounding box around the hands.</span></span> <span data-ttu-id="8f7ed-137">保险箱区域定义为使用， [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 但也适用于其他控制器类型。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-137">Safe zones are defined to work with [`IMixedRealityHand`](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with other controller types.</span></span> <span data-ttu-id="8f7ed-138">建议你了解每个安全区域在不同控制器类型上代表的内容。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-138">It is recommended to explore what each safe zone represents on different controller types.</span></span>

* <span data-ttu-id="8f7ed-139">**朝** 上的照相机在这种情况下，求解器将按照手型旋转，直至菜单与看起来充分对齐，此时它会给照相机旋转。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-139">**Follow Hand Until Facing Camera** With this active, solver will follow hand rotation until the menu is sufficiently aligned with the gaze, at which point it faces the camera.</span></span> <span data-ttu-id="8f7ed-140">这可以通过将 HandConstraintSolver 中的 SolverRotationBehavior （从 LookAtTrackedObject 更改为 LookAtMainCamera）与 GazeAlignment 的角变化来实现。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-140">This works by changing the SolverRotationBehavior in the HandConstraintSolver, from LookAtTrackedObject to LookAtMainCamera as the GazeAlignment angle with the solver varies.</span></span>

<img src="../images/solver/MRTK_Solver_HandConstraintSafeZones.png" width="450" alt="HandMenu Safe Zones">

* <span data-ttu-id="8f7ed-141">**激活事件**：目前 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 触发了四个激活事件。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-141">**Activation Events**: Currently the [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) triggers four activation events.</span></span> <span data-ttu-id="8f7ed-142">可以在许多不同的组合中使用这些事件来创建独特 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 的行为， `MRTK/Examples/Demos/HandTracking/Scenes/` 有关这些行为的示例，请参阅下的 HandBasedMenuExample 场景。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-142">These events can be used in many different combinations to create unique [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behaviors, please see the HandBasedMenuExample scene under `MRTK/Examples/Demos/HandTracking/Scenes/` for examples of these behaviors.</span></span>

  * <span data-ttu-id="8f7ed-143">*OnHandActivate*：当手满足 IsHandActive 方法时触发。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-143">*OnHandActivate*: triggers when a hand satisfies the IsHandActive method.</span></span>
  * <span data-ttu-id="8f7ed-144">*OnHandDeactivate*： IsHandActive 方法不再满足时触发触发器。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-144">*OnHandDeactivate*: triggers when the IsHandActive method is no longer satisfied.</span></span>
  * <span data-ttu-id="8f7ed-145">*OnFirstHandDetected*：手动跟踪状态从无干预视图更改为视图中的第一批时发生。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-145">*OnFirstHandDetected*: occurs when the hand tracking state changes from no hands in view, to the first hand in view.</span></span>
  * <span data-ttu-id="8f7ed-146">*OnLastHandLost*：在从视图中的至少一个手更改手动跟踪状态时发生。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-146">*OnLastHandLost*: occurs when the hand tracking state changes from at least one hand in view, to no hands in view.</span></span>

* <span data-ttu-id="8f7ed-147">**规划求解激活/停用逻辑**：当前用于激活和停用逻辑的建议 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 是通过使用 SolverHandler 的 UpdateSolver 值来实现，而不是通过禁用/启用对象来实现。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-147">**Solver Activation/Deactivation Logic**: Currently the recommendation for activating and deactivating [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) logic is to do so through the use of the SolverHandler's UpdateSolver value, rather than by disabling/enabling the object.</span></span> <span data-ttu-id="8f7ed-148">在示例场景中，可以通过在附加菜单的 ManipulationHandler "OnManipulationStarted/结束" 事件后触发的基于编辑器的挂钩来查看。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-148">This can be seen in the example scene through the editor-based hooks triggered after the attached menu's ManipulationHandler "OnManipulationStarted/Ended" events.</span></span>

  * <span data-ttu-id="8f7ed-149">*正在停止手动约束逻辑*：尝试将手动约束的对象设置为 "停止" (并且不运行激活/停用逻辑) 时，请将 UpdateSolver 设置为 False，而不是禁用 HandConstraintPalmUp。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-149">*Stopping the hand-constraint logic*: When trying to set the hand constrained object to stop (as well as not run the activation/deactivation logic), set UpdateSolver to False rather than disabling HandConstraintPalmUp.</span></span>
    * <span data-ttu-id="8f7ed-150">如果你想要启用基于注视的 (甚至不是基于注视的) 重新附加逻辑，则随后将调用 StartWorldLockReattachCheckCoroutine () 函数。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-150">If you want to enable the gaze-based (or even non-gaze-based) Reattach logic, this is then followed by calling the HandConstraintPalmUp.StartWorldLockReattachCheckCoroutine() function.</span></span> <span data-ttu-id="8f7ed-151">这会触发一个协同程序，它会继续检查是否满足 "IsValidController" 条件，并将 UpdateSolver 设置为 True (或禁用对象) </span><span class="sxs-lookup"><span data-stu-id="8f7ed-151">This will trigger a coroutine that then continues to check if the "IsValidController" criteria is met and will set UpdateSolver to True once it is (or the object is disabled)</span></span>
  * <span data-ttu-id="8f7ed-152">*启动手动约束逻辑*：尝试将手动约束的对象设置为根据其是否满足激活) 条件 (再次开始后，请将 SolverHandler 的 UpdateSolver 设置为 true。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-152">*Starting the hand-constraint logic*: When trying to set the hand constrained object to start following your hand again (based on whether it meets the activation criteria), set the SolverHandler's UpdateSolver to true.</span></span>

* <span data-ttu-id="8f7ed-153">重新 **附加逻辑**：目前， [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 无论 SolverHandler 的 UpdateSolver 是否为 True，都可以自动将目标对象重新附加到跟踪的点。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-153">**Reattach Logic**: Currently the [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is able to automatically reattach the target object to the tracked point, regardless of whether the SolverHandler's UpdateSolver is True or not.</span></span> <span data-ttu-id="8f7ed-154">这是通过调用 HandConstraintPalmUp 的 StartWorldLockReattachCheckCoroutine () 函数来实现的，在这种情况下， (它会将 SolverHandler 的 UpdateSolver 有效地设置为 False) 。</span><span class="sxs-lookup"><span data-stu-id="8f7ed-154">This is done through calling the HandConstraintPalmUp's StartWorldLockReattachCheckCoroutine() function, after it's been world-locked (which in this case, is effectively setting the SolverHandler's UpdateSolver to False).</span></span>

## <a name="see-also"></a><span data-ttu-id="8f7ed-155">另请参阅</span><span class="sxs-lookup"><span data-stu-id="8f7ed-155">See also</span></span>

* [<span data-ttu-id="8f7ed-156">Button</span><span class="sxs-lookup"><span data-stu-id="8f7ed-156">Button</span></span>](button.md)
* [<span data-ttu-id="8f7ed-157">邻近菜单</span><span class="sxs-lookup"><span data-stu-id="8f7ed-157">Near Menu</span></span>](near-menu.md)
