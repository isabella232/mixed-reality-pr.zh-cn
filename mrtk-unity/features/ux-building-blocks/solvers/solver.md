---
title: 求解器概述
description: MRTK 中的求解器概述
author: CDiaz-MS
ms.author: cadia
ms.date: 01/12/2021
ms.localizationpriority: high
keywords: Unity,HoloLens, HoloLens 2, 混合现实, 开发, MRTK, 求解器,
ms.openlocfilehash: bf9bbfe578ace576fca8870f038f145037a6838d
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/01/2021
ms.locfileid: "113176453"
---
# <a name="solver-overview"></a><span data-ttu-id="4e97a-104">求解器概述</span><span class="sxs-lookup"><span data-stu-id="4e97a-104">Solver overview</span></span>

![求解器主要内容](../../images/solver/MRTK_Solver_Main.png)

<span data-ttu-id="4e97a-106">求解器是有助于根据预定义算法计算对象位置和方向的组件。</span><span class="sxs-lookup"><span data-stu-id="4e97a-106">Solvers are components that facilitate the means of calculating an object's position & orientation according to a predefined algorithm.</span></span> <span data-ttu-id="4e97a-107">例如，将对象放置在用户当前注视视线直达的表面上。</span><span class="sxs-lookup"><span data-stu-id="4e97a-107">An example may be placing an object on the surface the user's gaze raycast currently hits.</span></span>

<span data-ttu-id="4e97a-108">此外，求解器系统确定性地定义这些转换计算的运算顺序，因为没有可靠的方法向 Unity 指定组件的更新顺序。</span><span class="sxs-lookup"><span data-stu-id="4e97a-108">Furthermore, the Solver system deterministically defines an order of operations for these transform calculations as there is no reliable way to specify to Unity the update order for components.</span></span>

<span data-ttu-id="4e97a-109">求解器提供一系列行为，以将对象附加到其他对象或系统。</span><span class="sxs-lookup"><span data-stu-id="4e97a-109">Solvers offer a range of behaviors to attach objects to other objects or systems.</span></span> <span data-ttu-id="4e97a-110">另一个示例是一个尾随对象，该对象悬停在用户前面（基于摄像机）。</span><span class="sxs-lookup"><span data-stu-id="4e97a-110">One other example would be a tag-along object that hovers in front of the user (based on the camera).</span></span> <span data-ttu-id="4e97a-111">求解器还可以附加到控制器和对象，使对象尾随控制器。</span><span class="sxs-lookup"><span data-stu-id="4e97a-111">A solver could also be attached to a controller and an object to make the object tag-along the controller.</span></span> <span data-ttu-id="4e97a-112">所有求解器都可以安全地堆叠，例如尾随行为 + 表面磁性 + 动量。</span><span class="sxs-lookup"><span data-stu-id="4e97a-112">All solvers can be safely stacked, for example a tag-along behavior + surface magnetism + momentum.</span></span>

## <a name="how-to-use-a-solver"></a><span data-ttu-id="4e97a-113">如何使用求解器</span><span class="sxs-lookup"><span data-stu-id="4e97a-113">How to use a solver</span></span>

<span data-ttu-id="4e97a-114">求解器系统由三类脚本组成：</span><span class="sxs-lookup"><span data-stu-id="4e97a-114">The Solver system consists of three categories of scripts:</span></span>

* <span data-ttu-id="4e97a-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver)：基本抽象类，用于派生所有求解器。</span><span class="sxs-lookup"><span data-stu-id="4e97a-115">[`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver): The base abstract class that all solvers derive from.</span></span> <span data-ttu-id="4e97a-116">它提供状态跟踪、平滑参数和实现、自动求解器系统集成和更新顺序。</span><span class="sxs-lookup"><span data-stu-id="4e97a-116">It provides state tracking, smoothing parameters and implementation, automatic solver system integration, and update order.</span></span>
* <span data-ttu-id="4e97a-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)：设置跟踪所参照的对象（例如：主摄像头转换、手部射线等），处理求解器组件收集以及按正确顺序执行更新。</span><span class="sxs-lookup"><span data-stu-id="4e97a-117">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler): Sets the reference object to track against (ex: the main camera transform, hand ray, etc.), handles gathering of solver components, and executes updating them in the proper order.</span></span>

<span data-ttu-id="4e97a-118">第三个类别是求解器本身。</span><span class="sxs-lookup"><span data-stu-id="4e97a-118">The third category is the solver itself.</span></span> <span data-ttu-id="4e97a-119">以下求解器提供基本行为的构建基块：</span><span class="sxs-lookup"><span data-stu-id="4e97a-119">The following solvers provide the building blocks for basic behavior:</span></span>

* <span data-ttu-id="4e97a-120">[`Orbital`](#orbital)：锁定到指定位置并偏离参照对象。</span><span class="sxs-lookup"><span data-stu-id="4e97a-120">[`Orbital`](#orbital): Locks to a specified position and offset from the referenced object.</span></span>
* <span data-ttu-id="4e97a-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize)：缩放以保持相对于参照对象视图不变的大小。</span><span class="sxs-lookup"><span data-stu-id="4e97a-121">[`ConstantViewSize`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.ConstantViewSize): Scales to maintain a constant size relative to the view of the referenced object.</span></span>
* <span data-ttu-id="4e97a-122">[`RadialView`](#radialview)：使对象保持在参照对象的视锥投射范围内。</span><span class="sxs-lookup"><span data-stu-id="4e97a-122">[`RadialView`](#radialview): Keeps the object within a view cone cast by the referenced object.</span></span>
* <span data-ttu-id="4e97a-123">[`Follow`](#follow)：使对象保持在参照对象的一组用户定义边界内。</span><span class="sxs-lookup"><span data-stu-id="4e97a-123">[`Follow`](#follow): Keeps the object within a set of user defined bounds of the referenced object.</span></span>
* <span data-ttu-id="4e97a-124">[`InBetween`](#inbetween)：使对象保持在两个跟踪对象之间。</span><span class="sxs-lookup"><span data-stu-id="4e97a-124">[`InBetween`](#inbetween): Keeps an object in between two tracked objects.</span></span>
* <span data-ttu-id="4e97a-125">[`SurfaceMagnetism`](#surfacemagnetism)：将射线投射到世界中的表面上，并使对象对齐到该表面。</span><span class="sxs-lookup"><span data-stu-id="4e97a-125">[`SurfaceMagnetism`](#surfacemagnetism): casts rays to surfaces in the world, and align the object to that surface.</span></span>
* <span data-ttu-id="4e97a-126">[`DirectionalIndicator`](#directionalindicator)：确定作为方向指示器的对象的位置和方向。</span><span class="sxs-lookup"><span data-stu-id="4e97a-126">[`DirectionalIndicator`](#directionalindicator): Determines the position and orientation of an object as a directional indicator.</span></span> <span data-ttu-id="4e97a-127">从 SolverHandler 跟踪目标的参照点来看，此指示器将面向提供的 DirectionalTarget。</span><span class="sxs-lookup"><span data-stu-id="4e97a-127">From the point of reference of the SolverHandler Tracked Target, this indicator will orient towards the DirectionalTarget supplied.</span></span>
* <span data-ttu-id="4e97a-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum)：应用加速/速度/摩擦来模拟由其他求解器/组件移动的对象的动量和弹性。</span><span class="sxs-lookup"><span data-stu-id="4e97a-128">[`Momentum`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Momentum): Applies acceleration/velocity/friction to simulate momentum and springiness for an object being moved by other solvers/components.</span></span>
* <span data-ttu-id="4e97a-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup)：约束对象，使其在 GameObject 不会与手部交叉的区域跟随手部。</span><span class="sxs-lookup"><span data-stu-id="4e97a-129">[`HandConstraint`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Constrains object to follow hands in a region that doesn't intersect the GameObject with the hands.</span></span> <span data-ttu-id="4e97a-130">对手部约束的交互式内容很有用，如菜单等。此求解器旨在与 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 一起使用，但也可以与 [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController) 一起使用。</span><span class="sxs-lookup"><span data-stu-id="4e97a-130">Useful for hand constrained interactive content such as menus, etc. This solver is intended to work with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) but also works with [IMixedRealityController](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityController).</span></span>
* <span data-ttu-id="4e97a-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup)：派生自 HandConstraint，但包含用于测试手部在激活前是否手掌面向用户的逻辑。</span><span class="sxs-lookup"><span data-stu-id="4e97a-131">[`HandConstraintPalmUp`](#hand-menu-with-handconstraint-and-handconstraintpalmup): Derives from HandConstraint but includes logic to test if the palm is facing the user before activation.</span></span> <span data-ttu-id="4e97a-132">此求解器只能与 [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) 控制器一起使用，如果与其他控制器类型一起使用，此求解器的行为类似于基类。</span><span class="sxs-lookup"><span data-stu-id="4e97a-132">This solver only works with [IMixedRealityHand](xref:Microsoft.MixedReality.Toolkit.Input.IMixedRealityHand) controllers, with other controller types this solver will behave just like its base class.</span></span>

<span data-ttu-id="4e97a-133">要使用求解器系统，只需将上面所列任一组件添加到 GameObject 即可。</span><span class="sxs-lookup"><span data-stu-id="4e97a-133">In order to use the Solver system, simply add one of the components listed above to a GameObject.</span></span> <span data-ttu-id="4e97a-134">由于所有求解器都需要 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)，因此 Unity 会自动创建一个。</span><span class="sxs-lookup"><span data-stu-id="4e97a-134">Since all Solvers require a [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), one will be created automatically by Unity.</span></span>

> [!NOTE]
> <span data-ttu-id="4e97a-135">SolverExamples.scene 文件中介绍了如何使用求解器系统的示例。</span><span class="sxs-lookup"><span data-stu-id="4e97a-135">Examples of how to use the Solvers system can be found in the **SolverExamples.scene** file.</span></span>

## <a name="how-to-change-tracking-reference"></a><span data-ttu-id="4e97a-136">如何更改跟踪参照</span><span class="sxs-lookup"><span data-stu-id="4e97a-136">How to change tracking reference</span></span>

<span data-ttu-id="4e97a-137">[`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 组件的“跟踪目标类型”属性定义所有求解器将用来计算其算法的参照点。</span><span class="sxs-lookup"><span data-stu-id="4e97a-137">The *Tracked Target Type* property of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component defines the point of reference all solvers will use to calculate their algorithms.</span></span> <span data-ttu-id="4e97a-138">例如，具有简单 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 组件的 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) 值类型将产生从头部开始，沿着用户凝视方向发射出去的射线，用于求解射线到达的表面。</span><span class="sxs-lookup"><span data-stu-id="4e97a-138">For example, a value type of [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) with a simple [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component will result in a raycast from the head and in the direction of the user's gaze for solving what surface is hit.</span></span> <span data-ttu-id="4e97a-139">`TrackedTargetType` 属性的可能值包括：</span><span class="sxs-lookup"><span data-stu-id="4e97a-139">Potential values for the `TrackedTargetType` property are:</span></span>

* <span data-ttu-id="4e97a-140">*Hea*：参照点是主摄像头的转换</span><span class="sxs-lookup"><span data-stu-id="4e97a-140">*Head* : Point of reference is the transform of the main camera</span></span>
* <span data-ttu-id="4e97a-141">*ControllerRay*：参照点是控制器上的 [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) 转换（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-141">*ControllerRay*: Point of reference is the [`LinePointer`](xref:Microsoft.MixedReality.Toolkit.Input.LinePointer) transform on a controller (i.e</span></span> <span data-ttu-id="4e97a-142">运动控制器或手部控制器上的指针原点），指向直线射线方向</span><span class="sxs-lookup"><span data-stu-id="4e97a-142">pointer origin on a motion controller or hand controller) pointing in the direction of the line ray</span></span>
  * <span data-ttu-id="4e97a-143">使用 `TrackedHandedness` 属性选择惯用手偏好（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-143">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="4e97a-144">左、右、均可）</span><span class="sxs-lookup"><span data-stu-id="4e97a-144">Left, Right, Both)</span></span>
* <span data-ttu-id="4e97a-145">*HandJoint*：参照点是特定手部关节的转换</span><span class="sxs-lookup"><span data-stu-id="4e97a-145">*HandJoint*: Point of reference is the transform of a specific hand joint</span></span>
  * <span data-ttu-id="4e97a-146">使用 `TrackedHandedness` 属性选择惯用手偏好（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-146">Use the `TrackedHandedness` property to select the handedness preference (i.e</span></span> <span data-ttu-id="4e97a-147">左、右、均可）</span><span class="sxs-lookup"><span data-stu-id="4e97a-147">Left, Right, Both)</span></span>
  * <span data-ttu-id="4e97a-148">使用 `TrackedHandJoint` 属性确定要利用的关节转换</span><span class="sxs-lookup"><span data-stu-id="4e97a-148">Use the  `TrackedHandJoint` property to determine the joint transform to utilize</span></span>
* <span data-ttu-id="4e97a-149">*CustomOverride*：参照点来自于已分配的 `TransformOverride`</span><span class="sxs-lookup"><span data-stu-id="4e97a-149">*CustomOverride*: Point of reference from the assigned `TransformOverride`</span></span>

> [!NOTE]
> <span data-ttu-id="4e97a-150">对于 ControllerRay 和 HandJoint 类型，求解器处理程序将先尝试提供左侧控制器/手部转换，然后在前者不可用时提供右侧转换，或者除非 `TrackedHandedness` 属性另有指定。</span><span class="sxs-lookup"><span data-stu-id="4e97a-150">For both *ControllerRay* and *HandJoint* types, the solver handler will attempt to provide the left controller/hand transform first and then the right if the former is not available or unless the `TrackedHandedness` property specifies otherwise.</span></span>

<span data-ttu-id="4e97a-151">![求解器跟踪的对象](../../images/solver/TrackedObjectType-Example.gif) 
与每个 TrackedTargetType 关联的各种属性的示例</span><span class="sxs-lookup"><span data-stu-id="4e97a-151">![Solver Tracked Object](../../images/solver/TrackedObjectType-Example.gif) 
*Example of various properties associated with each TrackedTargetType*</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4e97a-152">大多数求解器使用 `SolverHandler` 提供的跟踪转换目标的前向向量。</span><span class="sxs-lookup"><span data-stu-id="4e97a-152">Most solvers use the forward vector of the tracked transform target supplied by the `SolverHandler`.</span></span> <span data-ttu-id="4e97a-153">使用“手部关节”跟踪目标类型时，手掌关节的前向向量可能会穿过手指，而非手掌。</span><span class="sxs-lookup"><span data-stu-id="4e97a-153">When using a *Hand Joint* tracked target type, the forward vector of the palm joint may point through the fingers and not through the palm.</span></span> <span data-ttu-id="4e97a-154">这取决于提供手部关节数据的平台。</span><span class="sxs-lookup"><span data-stu-id="4e97a-154">This depends on the platform supplying the hand joint data.</span></span> <span data-ttu-id="4e97a-155">对于输入模拟和 Windows Mixed Reality，穿过手掌指向上方的是“向上向量”（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-155">For input simulation and Windows Mixed Reality, it is the *up vector* that points up through the palm (i.e</span></span> <span data-ttu-id="4e97a-156">绿色向量向上，蓝色向量向前）。</span><span class="sxs-lookup"><span data-stu-id="4e97a-156">green vector is up, blue vector is forward).</span></span>
>
> ![前向向上向量](../../images/solver/HandJoint_ForwardUpVectors.png)
>
> <span data-ttu-id="4e97a-158">若要克服这个问题，可以将 `SolverHandler` 上的“其他旋转”属性更新为 <90, 0, 0>。</span><span class="sxs-lookup"><span data-stu-id="4e97a-158">To overcome this, update the *Additional Rotation* property on the `SolverHandler` to **<90, 0, 0>**.</span></span> <span data-ttu-id="4e97a-159">这将确保提供给求解器的前向向量穿过手掌，从手部向外指出去。</span><span class="sxs-lookup"><span data-stu-id="4e97a-159">This will ensure the forward vector supplied to solvers is pointing through the palm and outward away from the hand.</span></span>
>
> ![其他旋转](../../images/solver/SolverHandler_AdditionalRotation.png)
>
> <span data-ttu-id="4e97a-161">或者，使用“控制器射线”跟踪目标类型获取与手部指向相似的行为。</span><span class="sxs-lookup"><span data-stu-id="4e97a-161">Alternatively, use the *Controller Ray* tracked target type to get similar behavior for pointing with hands.</span></span>

## <a name="how-to-chain-solvers"></a><span data-ttu-id="4e97a-162">如何链接求解器</span><span class="sxs-lookup"><span data-stu-id="4e97a-162">How to chain solvers</span></span>

<span data-ttu-id="4e97a-163">您可以将多个 `Solver` 组件添加到同一 GameObject 来链接算法。</span><span class="sxs-lookup"><span data-stu-id="4e97a-163">It is possible to add multiple `Solver` components to the same GameObject thus chaining their algorithms.</span></span> <span data-ttu-id="4e97a-164">`SolverHandler` 组件负责更新同一 GameObject 上的所有求解器。</span><span class="sxs-lookup"><span data-stu-id="4e97a-164">The `SolverHandler` components handles updating all solvers on the same GameObject.</span></span> <span data-ttu-id="4e97a-165">默认情况下，`SolverHandler` 会在 Start 上调用 `GetComponents<Solver>()`，从而按求解器在检查器中显示的顺序返回求解器。</span><span class="sxs-lookup"><span data-stu-id="4e97a-165">By default the `SolverHandler` calls `GetComponents<Solver>()` on Start which will return the Solvers in the order that they appear in the inspector.</span></span>

<span data-ttu-id="4e97a-166">此外，将"更新的链接转换"属性设置为 true，会指示 `Solver` 将其计算的位置、方向和缩放保存到所有求解器都可以访问的中间变量（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-166">Furthermore, setting the *Updated Linked Transform* property to true will instruct that `Solver` to save its calculated position, orientation, & scale to an intermediary variable accessible by all Solvers (i.e</span></span> <span data-ttu-id="4e97a-167">`GoalPosition`).</span><span class="sxs-lookup"><span data-stu-id="4e97a-167">`GoalPosition`).</span></span> <span data-ttu-id="4e97a-168">如果为 false，`Solver` 将直接更新 GameObject 的转换。</span><span class="sxs-lookup"><span data-stu-id="4e97a-168">When false, the `Solver` will update the GameObject's transform directly.</span></span> <span data-ttu-id="4e97a-169">通过将转换属性保存至中间位置，其他求解器能够从中间变量开始执行其计算。</span><span class="sxs-lookup"><span data-stu-id="4e97a-169">By saving the transform properties to an intermediary location, other Solvers are able to perform their calculations starting from the intermediary variable.</span></span> <span data-ttu-id="4e97a-170">这是因为 Unity 不允许对 gameObject.transform 的更新在同一帧中堆叠。</span><span class="sxs-lookup"><span data-stu-id="4e97a-170">This is because Unity does not allow updates to gameObject.transform to stack within the same frame.</span></span>

> [!NOTE]
> <span data-ttu-id="4e97a-171">开发人员可以通过直接设置 `SolverHandler.Solvers` 属性来修改求解器的执行顺序。</span><span class="sxs-lookup"><span data-stu-id="4e97a-171">Developers can modify the order of execution of Solvers by setting the `SolverHandler.Solvers` property directly.</span></span>

## <a name="how-to-create-a-new-solver"></a><span data-ttu-id="4e97a-172">如何创建新的求解器</span><span class="sxs-lookup"><span data-stu-id="4e97a-172">How to create a new solver</span></span>

<span data-ttu-id="4e97a-173">所有求解器都必须继承自抽象基类 [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver)。</span><span class="sxs-lookup"><span data-stu-id="4e97a-173">All solvers must inherit from the abstract base class, [`Solver`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Solver).</span></span> <span data-ttu-id="4e97a-174">求解器扩展的主要要求涉及重写 `SolverUpdate` 方法。</span><span class="sxs-lookup"><span data-stu-id="4e97a-174">The primary requirements of a Solver extension involves overriding the `SolverUpdate` method.</span></span> <span data-ttu-id="4e97a-175">在此方法中，开发人员应将继承的 `GoalPosition`、`GoalRotation` 和 `GoalScale` 属性更新为所需值。</span><span class="sxs-lookup"><span data-stu-id="4e97a-175">In this method, developers should update the inherited `GoalPosition`, `GoalRotation` and `GoalScale` properties to the desired values.</span></span> <span data-ttu-id="4e97a-176">此外，将 `SolverHandler.TransformTarget` 用作使用者所需的参照帧通常十分有益。</span><span class="sxs-lookup"><span data-stu-id="4e97a-176">Furthermore, it is generally valuable to leverage `SolverHandler.TransformTarget` as the frame of reference desired by the consumer.</span></span>

<span data-ttu-id="4e97a-177">下面提供的代码提供了名为 `InFront` 的新求解器组件的示例，该组件将附加对象放在 `SolverHandler.TransformTarget` 前面 2 米处。</span><span class="sxs-lookup"><span data-stu-id="4e97a-177">The code provided below gives an example of a new Solver component called `InFront` that places the attached object 2m in front of the `SolverHandler.TransformTarget`.</span></span> <span data-ttu-id="4e97a-178">如果使用者将 `SolverHandler.TrackedTargetType` 设置为 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)，则 `SolverHandler.TransformTarget` 将是相机转换，因此该求解器会在每一帧将附加的 GameObject 放在用户凝视的前面的 2 米处。</span><span class="sxs-lookup"><span data-stu-id="4e97a-178">If the `SolverHandler.TrackedTargetType` is set by the consumer as [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the `SolverHandler.TransformTarget` will be the camera transform and thus this Solver will place the attached GameObject 2m in front of the users' gaze every frame.</span></span>

```c#
/// <summary>
/// InFront solver positions an object 2m in front of the tracked transform target
/// </summary>
public class InFront : Solver
{
    ...

    public override void SolverUpdate()
    {
        if (SolverHandler != null && SolverHandler.TransformTarget != null)
        {
            var target = SolverHandler.TransformTarget;
            GoalPosition = target.position + target.forward * 2.0f;
        }
    }
}
```

## <a name="solver-implementation-guides"></a><span data-ttu-id="4e97a-179">求解器实现指南</span><span class="sxs-lookup"><span data-stu-id="4e97a-179">Solver implementation guides</span></span>

### <a name="common-solver-properties"></a><span data-ttu-id="4e97a-180">常见求解器属性</span><span class="sxs-lookup"><span data-stu-id="4e97a-180">Common solver properties</span></span>

<span data-ttu-id="4e97a-181">每个求解器组件都有一组核心属性，这些属性是相同的，用于控制求解器行为。</span><span class="sxs-lookup"><span data-stu-id="4e97a-181">Every Solver component has a core-set of identical properties that control the core Solver behavior.</span></span>

<span data-ttu-id="4e97a-182">如果启用了“平滑处理”，则求解器将随着时间的推移，将 GameObject 的转换逐渐更新为计算值。</span><span class="sxs-lookup"><span data-stu-id="4e97a-182">If *Smoothing* is enabled, then the Solver will gradually update the transform of the GameObject over time to the calculated values.</span></span> <span data-ttu-id="4e97a-183">此更改的速度取决于每个转换组件的“LerpTime”属性。</span><span class="sxs-lookup"><span data-stu-id="4e97a-183">The speed of this change is determined by every transform component's *LerpTime* property.</span></span> <span data-ttu-id="4e97a-184">例如，MoveLerpTime 值越高，帧之间的移动增量就会越慢。</span><span class="sxs-lookup"><span data-stu-id="4e97a-184">For example, a higher *MoveLerpTime* value will result in slower increments in movement between frames.</span></span>

<span data-ttu-id="4e97a-185">如果启用了 MaintainScale，求解器将利用 GameObject 的默认本地缩放。</span><span class="sxs-lookup"><span data-stu-id="4e97a-185">If *MaintainScale* is enabled, then the Solver will utilize the GameObject's default local scale.</span></span>

<span data-ttu-id="4e97a-186">![核心求解器属性](../../images/solver/GeneralSolverProperties.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-186">![Core Solver Properties](../../images/solver/GeneralSolverProperties.png)</span></span>  
<span data-ttu-id="4e97a-187">*所有求解器组件都会继承的常见属性*</span><span class="sxs-lookup"><span data-stu-id="4e97a-187">*Common properties inherited by all Solver components*</span></span>

### <a name="orbital"></a><span data-ttu-id="4e97a-188">Orbital</span><span class="sxs-lookup"><span data-stu-id="4e97a-188">Orbital</span></span>

<span data-ttu-id="4e97a-189">[`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) 类是一个尾随组件，其行为类似于太阳系中的行星。</span><span class="sxs-lookup"><span data-stu-id="4e97a-189">The [`Orbital`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Orbital) class is a tag-along component that behaves like planets in a solar system.</span></span> <span data-ttu-id="4e97a-190">此求解器将确保附加的 GameObject 围绕着跟踪转换旋转。</span><span class="sxs-lookup"><span data-stu-id="4e97a-190">This Solver will ensure the attached GameObject orbits around the tracked transform.</span></span> <span data-ttu-id="4e97a-191">因此，如果 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 的“跟踪目标类型”设置为 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head)，则 GameObject 将按照所应用的固定偏移量，围绕用户的头部旋转。</span><span class="sxs-lookup"><span data-stu-id="4e97a-191">Thus, if the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head), then the GameObject will orbit around the user's head with a fixed offset applied.</span></span>

<span data-ttu-id="4e97a-192">开发人员可以修改此固定偏移量，以使菜单或其他场景组件保持在眼睛或腰部的高度，围绕在用户周围。</span><span class="sxs-lookup"><span data-stu-id="4e97a-192">Developers can modify this fixed offset to keep menus or other scene components at eye-level or at waist level etc. around a user.</span></span> <span data-ttu-id="4e97a-193">这可以通过修改“本地偏移量”和“全局偏移量”属性完成。</span><span class="sxs-lookup"><span data-stu-id="4e97a-193">This is done by modifying the *Local Offset* and *World Offset* properties.</span></span> <span data-ttu-id="4e97a-194">“方向类型”属性确定应用于对象的旋转，例如，对象应始终保持原始旋转，或者总是面向摄像头，或者面向驱动其位置的转换，等等。</span><span class="sxs-lookup"><span data-stu-id="4e97a-194">The *Orientation Type* property determines the rotation applied to the object if it should maintain its original rotation or always face the camera or face whatever transform is driving its position etc.</span></span>

<span data-ttu-id="4e97a-195">![Orbital 示例](../../images/solver/OrbitalExample.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-195">![Orbital Example](../../images/solver/OrbitalExample.png)</span></span>  
<span data-ttu-id="4e97a-196">*Orbital 示例*</span><span class="sxs-lookup"><span data-stu-id="4e97a-196">*Orbital example*</span></span>

### <a name="radialview"></a><span data-ttu-id="4e97a-197">RadialView</span><span class="sxs-lookup"><span data-stu-id="4e97a-197">RadialView</span></span>

<span data-ttu-id="4e97a-198">[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) 是另一个尾随组件，用于使 GameObject 的特定部分保持在用户视野的圆锥体内。</span><span class="sxs-lookup"><span data-stu-id="4e97a-198">The [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is another tag-along component that keeps a particular portion of a GameObject within the frustum of the user's view.</span></span>

<span data-ttu-id="4e97a-199">“最小和最大视场角度”属性决定了 GameObject 必须始终在视线范围内的部分的面积。</span><span class="sxs-lookup"><span data-stu-id="4e97a-199">The *Min & Max View Degrees* properties determines how large of a portion of the GameObject must always be in view.</span></span>

<span data-ttu-id="4e97a-200">“最小和最大距离”属性决定了 GameObject 应该与用户保持多远距离。</span><span class="sxs-lookup"><span data-stu-id="4e97a-200">The *Min & Max Distance* properties determines how far the GameObject should be kept from the user.</span></span> <span data-ttu-id="4e97a-201">例如，如果“最小距离”为 1 米，走向 GameObject 会将 GameObject 推开，以确保它永远不会距离用户短于 1 米。</span><span class="sxs-lookup"><span data-stu-id="4e97a-201">For example, walking towards the GameObject with a *Min Distance* of 1m will push the GameObject away to ensure it is never closer than 1m to the user.</span></span>

<span data-ttu-id="4e97a-202">通常，[`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) 会与设置为 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) 的“跟踪目标类型”一起使用，这样组件就会跟随用户凝视。</span><span class="sxs-lookup"><span data-stu-id="4e97a-202">Generally, the [`RadialView`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.RadialView) is used in conjunction with *Tracked Target Type* set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) so that the component follows the user's gaze.</span></span> <span data-ttu-id="4e97a-203">但是，此组件可以发挥作用，以保持在任何跟踪目标类型的“视线”范围内。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-203">However, this component can function to be kept in *"view"* of any *Tracked Target Type*.</span></span>

<span data-ttu-id="4e97a-204">![RadialView 示例](../../images/solver/RadialViewExample.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-204">![RadialView Example](../../images/solver/RadialViewExample.png)</span></span>  
<span data-ttu-id="4e97a-205">*RadialView 示例*</span><span class="sxs-lookup"><span data-stu-id="4e97a-205">*RadialView example*</span></span>

### <a name="follow"></a><span data-ttu-id="4e97a-206">关注</span><span class="sxs-lookup"><span data-stu-id="4e97a-206">Follow</span></span>

<span data-ttu-id="4e97a-207">[`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) 类将元素定位在跟踪目标的前面，相对于其局部前向轴。</span><span class="sxs-lookup"><span data-stu-id="4e97a-207">The [`Follow`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.Follow) class positions an element in front of the of the tracked target relative to its local forward axis.</span></span> <span data-ttu-id="4e97a-208">该元素可以是松散约束型（又称</span><span class="sxs-lookup"><span data-stu-id="4e97a-208">The element can be loosely constrained (a.k.a.</span></span> <span data-ttu-id="4e97a-209">尾随），这样只有在跟踪目标移动到用户定义边界之外时才会跟随目标。</span><span class="sxs-lookup"><span data-stu-id="4e97a-209">tag-along) so that it doesn't follow until the tracked target moves beyond user defined bounds.</span></span>

<span data-ttu-id="4e97a-210">它的工作方式类似于 RadialView 求解器，但具有更多控制，可以管理“最大水平和垂直视场角度”，此外还有用于更改对象“方向”的机制。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-210">It works similarly to the RadialView solver, with additional controls to manage *Max Horizontal & Vertical View Degrees*, and mechanisms to alter the *Orientation* of the object.</span></span>

<span data-ttu-id="4e97a-211">![Follow 属性](../../images/solver/FollowExample.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-211">![Follow properties](../../images/solver/FollowExample.png)</span></span>  
<span data-ttu-id="4e97a-212">*Follow 属性*</span><span class="sxs-lookup"><span data-stu-id="4e97a-212">*Follow properties*</span></span>

<span data-ttu-id="4e97a-213">![Follow 示例场景](../../images/solver/FollowExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="4e97a-213">![Follow example scene](../../images/solver/FollowExampleScene.gif)</span></span>  
<span data-ttu-id="4e97a-214">*Follow 示例场景 (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="4e97a-214">*Follow Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/FollowSolverExample.unity)*</span></span>

### <a name="inbetween"></a><span data-ttu-id="4e97a-215">InBetween</span><span class="sxs-lookup"><span data-stu-id="4e97a-215">InBetween</span></span>

<span data-ttu-id="4e97a-216">[`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 类使附加的 GameObject 保持在两个转换之间。</span><span class="sxs-lookup"><span data-stu-id="4e97a-216">The [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) class will keep the attached GameObject between two transforms.</span></span> <span data-ttu-id="4e97a-217">这两个转换终结点由 GameObject 自己的 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler)"跟踪目标类型"和 [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 组件的“第二个跟踪目标类型”属性定义。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-217">These two transform endpoints are defined by the GameObject's own [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) *Tracked Target Type* and the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component's *Second Tracked Target Type* property.</span></span> <span data-ttu-id="4e97a-218">通常，这两个类型都将设置为 [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride)，产生的 `SolverHandler.TransformOverride` 和 `InBetween.SecondTransformOverride` 值将设置为两个跟踪的终结点。</span><span class="sxs-lookup"><span data-stu-id="4e97a-218">Generally, both types will be set to [`CustomOverride`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.CustomOverride) and the resulting `SolverHandler.TransformOverride` and `InBetween.SecondTransformOverride` values set to the two tracked endpoints.</span></span>

<span data-ttu-id="4e97a-219">在运行时，[`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) 组件将基于“第二个跟踪目标类型”和“第二个转换覆盖”属性再创建一个 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 组件。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-219">At runtime, the [`InBetween`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.InBetween) component will create another [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) component based on the *Second Tracked Target Type* and *Second Transform Override* properties.</span></span>

<span data-ttu-id="4e97a-220">`PartwayOffset` 定义应在直线上两个转换之间的哪个位置放置对象，0.5 表示中间，1.0 表示第一个转换，0.0 表示第二个转换。</span><span class="sxs-lookup"><span data-stu-id="4e97a-220">The `PartwayOffset` defines where along the line between two transforms the object shall be placed with 0.5 as halfway, 1.0 at the first transform, and 0.0 at the second transform.</span></span>

<span data-ttu-id="4e97a-221">![InBetween 示例](../../images/solver/InBetweenExample.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-221">![InBetween Example](../../images/solver/InBetweenExample.png)</span></span>  
<span data-ttu-id="4e97a-222">*使用 InBetween 求解器使对象保持在两个转换之间的示例*</span><span class="sxs-lookup"><span data-stu-id="4e97a-222">*Example of using InBetween solver to keep object between two transforms*</span></span>

### <a name="surfacemagnetism"></a><span data-ttu-id="4e97a-223">SurfaceMagnetism</span><span class="sxs-lookup"><span data-stu-id="4e97a-223">SurfaceMagnetism</span></span>

<span data-ttu-id="4e97a-224">[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 的工作方式是对一组表面的 LayerMask 执行光线投射，并将 GameObject 放置在接触点。</span><span class="sxs-lookup"><span data-stu-id="4e97a-224">The [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) works by performing a raycast against a set LayerMask of surfaces and placing the GameObject at that point of contact.</span></span>

<span data-ttu-id="4e97a-225">“表面垂直偏移”按照设定好的距离表面的距离（米），沿着表面上击中点处的法线方向放置 GameObject。</span><span class="sxs-lookup"><span data-stu-id="4e97a-225">The *Surface Normal Offset* will place the GameObject a set distance in meters away from the surface in the direction of the normal at the hit point on the surface.</span></span>

<span data-ttu-id="4e97a-226">相反，“表面射线偏移”按照设定好的距离表面的距离（米），沿着所执行光线投射的相反方向放置 GameObject。</span><span class="sxs-lookup"><span data-stu-id="4e97a-226">Conversely, the *Surface Ray Offset* will place the GameObject a set distance in meters away from the surface but in the opposite direction of the raycast performed.</span></span> <span data-ttu-id="4e97a-227">因此，如果光线投射是用户凝视的方向，则 GameObject 将沿直线从表面上的击中点向摄像头靠近。</span><span class="sxs-lookup"><span data-stu-id="4e97a-227">Thus, if the raycast is the user's gaze, then the GameObject will move closer along the line from the hit point on the surface to the camera.</span></span>

<span data-ttu-id="4e97a-228">“方向模式”确定相对于表面上的法线应用的旋转类型。</span><span class="sxs-lookup"><span data-stu-id="4e97a-228">The *Orientation Mode* determines the type of rotation to apply in relation to the normal on the surface.</span></span>

* <span data-ttu-id="4e97a-229">无 - 不应用旋转</span><span class="sxs-lookup"><span data-stu-id="4e97a-229">*None* - No rotation applied</span></span>
* <span data-ttu-id="4e97a-230">跟踪目标 - 对象将面向驱动光线投射的跟踪转换</span><span class="sxs-lookup"><span data-stu-id="4e97a-230">*TrackedTarget* - Object will face the tracked transform driving the raycast</span></span>
* <span data-ttu-id="4e97a-231">表面法线 - 对象将基于表面上的击中点对齐</span><span class="sxs-lookup"><span data-stu-id="4e97a-231">*SurfaceNormal* - Object will align based on normal at hit point on surface</span></span>
* <span data-ttu-id="4e97a-232">混合 - 对象将基于表面上的击中点对齐，并且面向跟踪转换。</span><span class="sxs-lookup"><span data-stu-id="4e97a-232">*Blended* - Object will align based on normal at hit point on surface AND based on facing the tracked transform.</span></span>

<span data-ttu-id="4e97a-233">要强制关联的 GameObject 在除“无”以外的任何模式下都保持垂直，请启用“使方向保持垂直”。</span><span class="sxs-lookup"><span data-stu-id="4e97a-233">To force the associated GameObject to stay vertical in any mode other than *None*, enable *Keep Orientation Vertical*.</span></span>

> [!NOTE]
> <span data-ttu-id="4e97a-234">当“方向模式”设置为“混合”时，使用“方向混合”属性控制旋转因子之间的平衡。  </span><span class="sxs-lookup"><span data-stu-id="4e97a-234">Use the *Orientation Blend* property to control the balance between rotation factors when *Orientation Mode* is set to *Blended*.</span></span> <span data-ttu-id="4e97a-235">如果值为 0.0，则方向完全由“跟踪目标”模式驱动，值为 1.0 时，方向完全由“表面法线”驱动。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-235">A value of 0.0 will have orientation entirely driven by *TrackedTarget* mode and a value of 1.0 will have orientation driven entirely by *SurfaceNormal*.</span></span>

![SurfaceMagnetism 示例](../../images/solver/SurfaceMagExample.png)

#### <a name="determining-what-surfaces-can-be-hit"></a><span data-ttu-id="4e97a-237">确定可以击中的表面</span><span class="sxs-lookup"><span data-stu-id="4e97a-237">Determining what surfaces can be hit</span></span>

<span data-ttu-id="4e97a-238">将 [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) 组件添加到 GameObject 时，必须考虑 GameObject 及其子代的层（如果任何子代有碰撞器）。</span><span class="sxs-lookup"><span data-stu-id="4e97a-238">When adding a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) component to a GameObject, it is important to consider the layer of the GameObject and its children, if any have colliders.</span></span> <span data-ttu-id="4e97a-239">该组件的工作方式是执行各种类型的光线投射，以确定哪些表面可以“吸附”光线。</span><span class="sxs-lookup"><span data-stu-id="4e97a-239">The component works by performing various types of raycasts to determine what surface to "magnet" itself against.</span></span> <span data-ttu-id="4e97a-240">如果求解器 GameObject 在 `SurfaceMagnetism` 的 `MagneticSurfaces` 属性所列的其中一个层上有碰撞器，那么光线投射很可能会击中自己，导致 GameObject 附加到其自己的碰撞器点。</span><span class="sxs-lookup"><span data-stu-id="4e97a-240">If the solver GameObject has a collider on one of the layers listed in the `MagneticSurfaces` property of `SurfaceMagnetism`, then the raycast will likely hit itself resulting in the GameObject attaching to its own collider point.</span></span> <span data-ttu-id="4e97a-241">这种异常行为是可以避免的，方法是将主 GameObject 和所有子代设置为“忽略光线投射”层或相应地修改 `MagneticSurfaces` LayerMask 数组。</span><span class="sxs-lookup"><span data-stu-id="4e97a-241">This odd behavior can be avoided by setting the main GameObject and all children to the *Ignore Raycast* layer or modifying the `MagneticSurfaces` LayerMask array appropriately.</span></span>

<span data-ttu-id="4e97a-242">相反，[`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject 不会与 `MagneticSurfaces` 属性中未列出的层上的表面发生碰撞。</span><span class="sxs-lookup"><span data-stu-id="4e97a-242">Conversely, a [`SurfaceMagnetism`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SurfaceMagnetism) GameObject will not collide with surfaces on a layer not listed in the `MagneticSurfaces` property.</span></span> <span data-ttu-id="4e97a-243">通常建议将所有所需表面放在专用层上（即</span><span class="sxs-lookup"><span data-stu-id="4e97a-243">It is generally recommended to place all desired surfaces on a dedicated layer (i.e</span></span> <span data-ttu-id="4e97a-244">“表面”），并将 `MagneticSurfaces` 属性仅设置为这个层。</span><span class="sxs-lookup"><span data-stu-id="4e97a-244">*Surfaces*) and setting the `MagneticSurfaces` property to just this layer.</span></span>  <span data-ttu-id="4e97a-245">使用“默认”或“全部”可能会导致 UI 组件或光标影响求解器。 </span><span class="sxs-lookup"><span data-stu-id="4e97a-245">Using *default* or *everything* may result in UI components or cursors contributing to the solver.</span></span>

<span data-ttu-id="4e97a-246">最后，`SurfaceMagnetism` 光线投射将忽略 `MaxRaycastDistance` 属性设置，而不是表面。</span><span class="sxs-lookup"><span data-stu-id="4e97a-246">Finally, surfaces farther than the `MaxRaycastDistance` property setting will be ignored by the `SurfaceMagnetism` raycasts.</span></span>

### <a name="directionalindicator"></a><span data-ttu-id="4e97a-247">DirectionalIndicator</span><span class="sxs-lookup"><span data-stu-id="4e97a-247">DirectionalIndicator</span></span>

<span data-ttu-id="4e97a-248">[`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) 类是一个尾随组件，它可以根据空间中指定点的方向调整自身方向。</span><span class="sxs-lookup"><span data-stu-id="4e97a-248">The [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) class is a tag-along component that orients itself to the direction of a desired point in space.</span></span>

<span data-ttu-id="4e97a-249">最常用于 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 的“跟踪目标类型”设置为 [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head) 的情况。</span><span class="sxs-lookup"><span data-stu-id="4e97a-249">Most commonly used when the *Tracked Target Type* of the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) is set to [`Head`](xref:Microsoft.MixedReality.Toolkit.Utilities.TrackedObjectType.Head).</span></span> <span data-ttu-id="4e97a-250">这样，具有 [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator) 求解器的 UX 组件将指引用户看空间中的指定点。</span><span class="sxs-lookup"><span data-stu-id="4e97a-250">In this fashion, a UX component with the [`DirectionalIndicator`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.DirectionalIndicator)  solver will direct a user to look at the desired point in space.</span></span>

<span data-ttu-id="4e97a-251">空间中的指定点通过“方向目标”属性确定。</span><span class="sxs-lookup"><span data-stu-id="4e97a-251">The desired point in space is determined via the *Directional Target* property.</span></span>

<span data-ttu-id="4e97a-252">如果用户可以查看方向目标，或在 [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler) 中设置了任何参照帧，则该求解器将禁用它下面的所有 [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) 组件。</span><span class="sxs-lookup"><span data-stu-id="4e97a-252">If the directional target is viewable by the user, or whatever frame of reference is set in the [`SolverHandler`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.SolverHandler), then this solver will disable all [`Renderer`](https://docs.unity3d.com/ScriptReference/Renderer.html) components underneath it.</span></span> <span data-ttu-id="4e97a-253">如果不可查看，则该指示器上将启用所有内容。</span><span class="sxs-lookup"><span data-stu-id="4e97a-253">If not viewable, then everything will be enabled on the indicator.</span></span>

<span data-ttu-id="4e97a-254">随着用户逐渐靠近以在他们的 FOV 中捕捉“方向目标”，指示器的大小将缩小。</span><span class="sxs-lookup"><span data-stu-id="4e97a-254">The size of the indicator will shrink the closer the user is to capturing the *Directional Target* in their FOV.</span></span>

* <span data-ttu-id="4e97a-255">最小指示器比例 - 指示器对象的最小比例</span><span class="sxs-lookup"><span data-stu-id="4e97a-255">*Min Indicator Scale* - The minimum scale for the indicator object</span></span>
* <span data-ttu-id="4e97a-256">最大指示器比例 - 指示器对象的最大比例</span><span class="sxs-lookup"><span data-stu-id="4e97a-256">*Max Indicator Scale* - The maximum scale for the indicator object</span></span>

* <span data-ttu-id="4e97a-257">可见性比例因子 - 用于增加或减少 FOV 的乘数，用于确定“方向目标”点是否可见</span><span class="sxs-lookup"><span data-stu-id="4e97a-257">*Visibility Scale Factor* - Multiplier to increase or decrease the FOV that determines if the *Directional Target* point is viewable or not</span></span>
* <span data-ttu-id="4e97a-258">视线偏移 - 从参照帧的视角（即，</span><span class="sxs-lookup"><span data-stu-id="4e97a-258">*View Offset* - From the viewpoint of the frame of reference (i.e</span></span> <span data-ttu-id="4e97a-259">很有可能是摄像头），此属性定义对象在指示器方向距离视角中心多远的位置处。</span><span class="sxs-lookup"><span data-stu-id="4e97a-259">camera possibly), this property defines how far in the indicator direction should the object be from the center of the viewport.</span></span>

<span data-ttu-id="4e97a-260">![DirectionalIndicator 属性](../../images/solver/DirectionalIndicatorExample.png)</span><span class="sxs-lookup"><span data-stu-id="4e97a-260">![Directional Indicator properties](../../images/solver/DirectionalIndicatorExample.png)</span></span>  
<span data-ttu-id="4e97a-261">*DirectionalIndicator 属性*</span><span class="sxs-lookup"><span data-stu-id="4e97a-261">*Directional Indicator properties*</span></span>

<span data-ttu-id="4e97a-262">![DirectionalIndicator 示例场景](../../images/solver/DirectionalIndicatorExampleScene.gif)</span><span class="sxs-lookup"><span data-stu-id="4e97a-262">![Directional Indicator example scene](../../images/solver/DirectionalIndicatorExampleScene.gif)</span></span>  
<span data-ttu-id="4e97a-263">*DirectionalIndicator 示例场景 (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span><span class="sxs-lookup"><span data-stu-id="4e97a-263">*Directional Indicator Example Scene (Assets/MRTK/Examples/Demos/Solvers/Scenes/DirectionalIndicatorSolverExample.unity)*</span></span>

### <a name="hand-menu-with-handconstraint-and-handconstraintpalmup"></a><span data-ttu-id="4e97a-264">带有 HandConstraint 和 HandConstraintPalmUp 的手部菜单</span><span class="sxs-lookup"><span data-stu-id="4e97a-264">Hand menu with HandConstraint and HandConstraintPalmUp</span></span>

![手部菜单 UX 示例](../../images/solver/MRTK_UX_HandMenu.png)

<span data-ttu-id="4e97a-266">[`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 行为提供了一个求解器，该求解器将跟踪对象约束在确保可显示手部约束内容（如手部 UI、菜单等）的区域内。</span><span class="sxs-lookup"><span data-stu-id="4e97a-266">The [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) behavior provides a solver that constrains the tracked object to a region safe for hand constrained content (such as hand UI, menus, etc).</span></span> <span data-ttu-id="4e97a-267">安全区域是指不会与手部相交的区域。</span><span class="sxs-lookup"><span data-stu-id="4e97a-267">Safe regions are considered areas that don't intersect with the hand.</span></span> <span data-ttu-id="4e97a-268">还包含了一个名为 [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) 的 [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) 派生类，用于演示手掌朝向用户时激活求解器的常见行为。</span><span class="sxs-lookup"><span data-stu-id="4e97a-268">A derived class of [`HandConstraint`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraint) called [`HandConstraintPalmUp`](xref:Microsoft.MixedReality.Toolkit.Utilities.Solvers.HandConstraintPalmUp) is also included to demonstrate a common behavior of activating the solver tracked object when the palm is facing the user.</span></span>

<span data-ttu-id="4e97a-269">[另请参阅“手部菜单”页面](../hand-menu.md)，了解使用手部约束求解器创建手部菜单的示例。</span><span class="sxs-lookup"><span data-stu-id="4e97a-269">[Please see Hand Menu page](../hand-menu.md) for the examples of using Hand Constraint solver to create hand menus.</span></span>

## <a name="see-also"></a><span data-ttu-id="4e97a-270">另请参阅</span><span class="sxs-lookup"><span data-stu-id="4e97a-270">See also</span></span>

* [<span data-ttu-id="4e97a-271">手部跟踪</span><span class="sxs-lookup"><span data-stu-id="4e97a-271">Hand Tracking</span></span>](../../input/hand-tracking.md)
* [<span data-ttu-id="4e97a-272">凝视</span><span class="sxs-lookup"><span data-stu-id="4e97a-272">Gaze</span></span>](../../input/gaze.md)
