---
title: 重大更改
description: 有关 MRTK 中的中断性变更的策略。
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, 混合现实, 开发, MRTK,
ms.openlocfilehash: 713cb5a0965d713c7073004059218ab2ab37201d
ms.sourcegitcommit: 8b4c2b1aac83bc8adf46acfd92b564f899ef7735
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/30/2021
ms.locfileid: "113121545"
---
# <a name="breaking-changes"></a>中断性变更

MRTK 的使用者依赖于具有稳定的版本到发布 API 图面，以便他们可以对 MRTK 进行更新，而无需每次进行较大的中断性变更。

本页介绍有关 MRTK 中的中断性变更的当前策略，以及围绕如何更好地管理中断性变更与能够对代码进行正确长期技术更改之间的权衡的一些长期目标。

## <a name="what-is-a-breaking-change"></a>什么是中断性变更？

如果更改满足列表 [A](#list-a) 中的任意条件，并且满足列表 B 中的所有条件，则更改是 [一项中断性变更](#list-b)

### <a name="list-a"></a>列出 A

- 添加、删除或更新任何接口的成员或函数 (整个接口的删除/重命名) 。
- 删除、更新 (/定义，使类的任何受保护) 公共成员或函数具有私有或内部属性。  (删除/重命名整个类) 。
- 类触发的事件顺序更改。
- 重命名任何私有 SerializedField (ScriptableObject 上没有相应的 FormerlySerializedAs 标记) 或公共属性 (尤其是对配置文件) 。
- 更改 ScriptableObject 上的字段类型 (更改配置文件) 。
- 更新任何类或接口的命名空间或 asmdef。
- 删除预制项的顶级对象上的任何预制名或删除脚本。

### <a name="list-b"></a>列表 B

- 该资产位于基础 (包中，即位于以下文件夹之一) ：

  - MRTK/Core
  - MRTK/Providers/
  - MRTK/Services/
  - MRTK/SDK/
  - MRTK/扩展

- 该资产不属于实验命名空间。

> [!IMPORTANT]
> 位于示例包 (即 MRTK/Examples/文件夹) 的一部分）的任何资产随时可能更改，因为其中的资产被设计为被使用者复制和查看为"引用实现"，但不是 API 和资产的核心集的一部分。 试验命名空间中的资产 (或更一般地是标记为实验性) 的功能，这些功能是在完成所有适当调查之前发布的 (即测试、UX 迭代、文档) 并提前发布，以更快获得反馈。  但是，由于它们没有测试和文档，并且由于我们可能尚未关闭所有交互和设计，因此，我们发布它们时，公众应假设它们可以并且将更改 (，即修改、完全删除等) 。
>
> 有关详细信息 [，请参阅](../contributing/experimental-features.md) 实验性功能。

由于重大更改的表面积非常大，因此必须注意，不可能有一条显示"无中断性变更"的绝对规则 ， 可能有一些问题可以通过中断性变更以安全的方式修复。 换一种方式来说，我们真正拥有"无中断性变更"的唯一方法就是没有任何更改。

我们一直的策略是避免在可能的情况下进行重大更改，并且仅在更改会累积重要的客户或框架长期价值时进行。

## <a name="what-to-do-about-breaking-changes"></a>要执行哪些中断性变更

如果无需中断性变更且不影响功能的长期结构和可行性即可完成某些操作，请不要进行中断性变更。 如果没有其他方法，当前策略是评估每个单独的中断性变更，以了解采用更改的好处是否大于使用者接受更改的成本。 有关值得执行哪些内容以及哪些不一定会在 PR 或问题讨论本身上进行的讨论。

此处发生的情况分为多个存储桶：

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>中断性变更可增加价值，但编写方式不会中断

例如，此 [PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 添加了一项新功能，该功能最初以中断方式编写，即修改了现有接口，但随后在功能被分解为其自己的接口时被重写。 这通常是可能的最佳结果。 如果这样做会损害功能的长期可行性或结构，请不要尝试强制更改为非中断性形式。

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>中断性变更为客户增加了足够的价值，值得执行

记录什么是中断性变更，并提供可能的最佳缓解措施 (即如何迁移的规范步骤，或针对客户部署自动迁移的更) 。 每个版本可能包含少量中断性变更 - 应始终在文档中记录这些更改，如此 [PR 中所做的一样](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)。 如果已有 2.x.x→2.x+1.x+1 迁移指南，则向该文档添加说明或工具。如果不存在，请创建它。

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>中断性变更增加了价值，但客户感到了太多

并非所有类型的中断性变更的创建方式都相同 - 根据我们的经验和客户体验，有些更改的创建方式明显更加困难。 例如，对接口的更改可能很麻烦，但如果中断性变更是客户不太可能在过去 (年扩展/实现诊断可视化系统（例如) ）的更改，则实际成本可能低到无。 但是，如果更改是 ScriptableObject (（例如，在 MRTK) 的核心配置文件上）上的字段类型，则这可能会导致大量客户感到沮丧。 客户已克隆默认配置文件，合并/更新配置文件可能非常难以手动执行 (即，在合并时间) 期间通过文本编辑器，重新复制默认配置文件并手动重新配置所有内容非常可能导致难以调试回归。

这些更改必须放回到架子上，直到分支存在，该分支将允许重大重大更改 (以及可为客户提供升级) 。 此类分支当前不存在。 在将来的迭代规划会议中，我们将查看一组"太中断"的更改/问题，看看我们是否达到了一个临界质量，使同时进行一组更改是合理的。 请注意，在未进行适当调查的情况下启动"一切允许"分支是危险的，因为我们的工程资源有限，并且我们必须将测试和验证拆分到这两个分支。 此类分支存在时，需要明确用途和传达良好的开始日期和结束日期。

## <a name="long-term-management-of-breaking-changes"></a>长期管理中断性变更

从长期来看，应该通过增加列表 B 中的条件集来缩小中断性变更 [的范围](#list-b)。从技术上来说，列表 [A](#list-a) 中的一组内容始终会破坏我们认为在"公共 API 图面"中的文件和资产集。 我们可以为迭代获得更多的自由 (即更改内部实现详细信息，以便更轻松地重构和共享多个类之间的代码等) 的方式是更明确地说明代码的哪些部分是官方图面，而不是实现细节。

我们已完成的一件事是引入"实验性"功能的概念 (该功能属于实验命名空间，可能没有测试/文档，并且已公开宣布存在，但可能会被删除和更新，而不会发出警告) 。 这样，我们可以尽快添加新功能以获得早期反馈，但不能立即绑定到其 API 图面 (因为我们可能尚未完全考虑 API 图面) 。

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>将来可能有所帮助的其他示例

- 内部关键字 [的用法](/dotnet/csharp/language-reference/keywords/internal)。
  这样，我们即可在其自己的程序集中共享代码 (减少代码重复) 而无需向外部使用者公开内容。
- 创建"内部"命名空间 (即 Microsoft.MixedReality.Toolkit.Internal.Utilities) ，我们在此公开记录该内部命名空间中包含的任何内容随时可能会更改，并且可能会被删除等。这类似于 C++ 标头库使用 ：：internal 命名空间隐藏其实现详细信息的方式。