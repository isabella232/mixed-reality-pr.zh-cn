---
title: 重大更改
description: 有关 MRTK 中中断性变更的策略。
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, 混合现实, 开发, MRTK,
ms.openlocfilehash: 5f48503c4d28316cad49fbdf8bc163399ca9f7ad
ms.sourcegitcommit: c0ba7d7bb57bb5dda65ee9019229b68c2ee7c267
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/19/2021
ms.locfileid: "110143497"
---
# <a name="breaking-changes"></a>中断性变更

MRTK 的使用者依赖于具有稳定的版本到发布 API 图面，以便他们可以对 MRTK 进行更新，而无需每次进行较大的中断性变更。

本页介绍有关 MRTK 中的中断性变更的当前策略，以及围绕如何更好地管理中断性变更与能够对代码进行正确长期技术更改之间的权衡的一些长期目标。

## <a name="what-is-a-breaking-change"></a>什么是中断性变更？

如果更改满足列表 [A](#list-a) 中的任意条件，并且满足列表 B 中的所有条件，则更改是 [一项中断性变更](#list-b)

### <a name="list-a"></a>列出 A

- 添加、删除或更新任何接口的成员或函数 (整个接口的删除/重命名) 。
- 删除、更新 (/定义，使类的任何受保护) 公共成员或函数具有私有或内部属性。  (删除/重命名整个类) 。
- 类触发的事件顺序更改。
- 重命名任何私有 SerializedField (ScriptableObject 上没有相应的 FormerlySerializedAs 标记) 或公共属性 (尤其是对配置文件) 。
- 更改 ScriptableObject 上的字段类型 (更改配置文件) 。
- 更新任何类或接口的命名空间或 asmdef。
- 删除预制项的顶级对象上的任何预制名或删除脚本。

### <a name="list-b"></a>列表 B

- 该资产位于基础 (包中，即位于以下文件夹之一) ：

  - MRTK/Core
  - MRTK/Providers/
  - MRTK/Services/
  - MRTK/SDK/
  - MRTK/Extensions

- 相关资产不属于实验命名空间。

> [!IMPORTANT]
> 位于示例包中的任何资产 (（即 MRTK/示例/文件夹) 的一部分）随时可以更改，因为使用者可以将其作为 "引用实现" 进行复制和查看，但不是 Api 和资产的核心集的一部分。 实验命名空间中的资产 (或更常见，标记为实验性) 的功能是在完成所有截止工作之前发布的功能 (例如，测试、UX 迭代、文档) 并及早发布，以便更快地获取反馈。  不过，由于它们没有测试和文档，而且可能尚未明确所有交互和设计，因此，我们会将其发布到公共应假设它们可以和将更改 (即修改、完全删除等) 的状态。
>
> 有关详细信息，请参阅 [实验性功能](../contributing/experimental-features.md) 。

因为重大更改的外围应用非常大，所以请务必注意，具有显示 "无重大更改" 的绝对规则可能是不可能的，这可能是由于发生重大更改而只能通过合理方式解决的问题。 作为另一种方法，我们真正可以说，"无重大更改" 是指根本不进行任何更改。

我们的主要策略是避免在可能的情况下进行重大更改，并且仅在更改会使重要的客户或框架长期价值时才会发生这种情况。

## <a name="what-to-do-about-breaking-changes"></a>如何应对重大更改

如果可以在没有重大更改的情况下完成某个操作，并且不会影响长期的结构和生存能力，请不要执行重大更改。 如果没有其他方法，则当前策略是评估每个重大更改，以了解取得更改的好处是否超出了使用者吸收更改的成本。 探讨需要做什么，通常不会发生 PR 或问题讨论本身。

此处发生的情况分为多个存储桶：

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a>中断性变更可增加价值，但编写方式不会中断

例如，此 [PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 添加了一项新功能，该功能最初以中断方式编写，即修改了现有接口，但随后在功能被分解为其自己的接口时被重写。 这通常是可能的最佳结果。 如果这样做会损害功能的长期可行性或结构，请不要尝试强制更改为非中断性形式。

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a>中断性变更为客户增加了足够的价值，值得执行

记录什么是中断性变更，并提供可能的最佳缓解措施 (即如何迁移的规范步骤，或针对客户部署自动迁移的更) 。 每个版本可能包含少量中断性变更 - 应始终在文档中记录这些更改，如此 [PR 中所做的一样](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)。 如果已有 2.x.x→2.x+1.x+1 迁移指南，则向该文档添加说明或工具。如果不存在，请创建它。

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a>中断性变更增加了价值，但客户感到了太多

并非所有类型的中断性变更的创建方式都相同 - 根据我们的经验和客户体验，有些更改的创建方式明显更加困难。 例如，对接口的更改可能很麻烦，但如果中断性变更是客户不太可能在过去 (年扩展/实现诊断可视化系统（例如) ）的更改，则实际成本可能低到无。 但是，如果更改是 ScriptableObject (（例如，在 MRTK) 的核心配置文件上）上的字段类型，则这可能会导致大量客户感到沮丧。 客户已经克隆了默认配置文件，合并/更新配置文件可能非常难以手动执行 (即，在合并期间通过文本编辑器) ，并重新复制默认配置文件并重新配置所有内容，这极有可能导致难以调试回归。

必须将这些更改放回到托架上，直到存在一个分支存在，这将导致重大更改 (以及将为客户提供升级) 的重要价值。 此类分支当前不存在。 在我们未来的迭代规划会议中，我们将回顾一组 "过于严重" 的更改/问题，以确定我们是否达到了一项关键的质量，以便能够合理地执行一组更改。 请注意，由于我们拥有的工程资源有限，因此，启动 "一切都是允许的" 分支，而不是由于有限的工程资源而进行 此类分支存在时，需要有一个明确的用途和良好的通信开始和结束日期。

## <a name="long-term-management-of-breaking-changes"></a>重大更改的长期管理

从长远来看，我们应该设法通过增加 [列表 B](#list-b)中的条件集来减少重大更改的范围。今后，在 [列表 A](#list-a) 中进行一组任务，对于我们认为位于 "公共 API 图面" 的一组文件和资产，将始终中断。 我们可以更自由地利用迭代 (例如，通过更改内部实现详细信息，以便更轻松地在多个类之间重构和共享代码，如) 更明确地说明代码的哪些部分是官方面，而不是实现详细信息。

我们所做的一件事就是介绍了 "实验性" 功能 (的概念，该功能在实验命名空间中存在，它可能没有测试/文档，而且可能会被删除并更新，而不) 警告。 这样，我们可以尽快添加新功能以获得早期反馈，但不能立即绑定到其 API 图面 (因为我们可能尚未完全考虑 API 图面) 。

### <a name="other-examples-of-things-that-could-help-in-the-future"></a>将来可能有所帮助的其他示例

- 内部关键字 [的用法](/dotnet/csharp/language-reference/keywords/internal)。
  这样，我们即可在其自己的程序集中共享代码 (减少代码重复) 而无需向外部使用者公开内容。
- 创建"内部"命名空间 (即 Microsoft.MixedReality.Toolkit.Internal.Utilities) ，我们在此公开记录该内部命名空间中包含的任何内容随时可能会更改，并且可能会被删除等。这类似于 C++ 标头库使用 ：：internal 命名空间隐藏其实现详细信息的方式。