---
title: 重大更改
description: 有关 MRTK 中的重大更改的策略。
author: polar-kev
ms.author: kesemple
ms.date: 01/12/2021
keywords: Unity, HoloLens, HoloLens 2, 混合现实, 开发, MRTK,
ms.openlocfilehash: 4cd5e0b085a182377aacdf35e1298ad1180ee641
ms.sourcegitcommit: f338b1f121a10577bcce08a174e462cdc86d5874
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 07/01/2021
ms.locfileid: "113177268"
---
# <a name="breaking-changes"></a><span data-ttu-id="b0bc3-104">中断性变更</span><span class="sxs-lookup"><span data-stu-id="b0bc3-104">Breaking changes</span></span>

<span data-ttu-id="b0bc3-105">MRTK 的使用者依赖于具有稳定的版本到发布的 API 图面，因此，它们可以对 MRTK 进行更新，而无需每次进行大量的重大更改。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-105">Consumers of the MRTK depend on having a stable release-to-release API surface, so that they can take updates to the MRTK without having large breaking changes each time.</span></span>

<span data-ttu-id="b0bc3-106">本页介绍了有关 MRTK 中的重大更改的当前策略，以及围绕如何更好地管理重大更改与对代码进行正确的长期技术更改之间的一些更长期的目标。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-106">This page describes our current policy regarding breaking changes in the MRTK, along with some longer term goals around how we can better manage the tradeoff between keeping breaking changes low and being able to make the right long term technical changes to the code.</span></span>

## <a name="what-is-a-breaking-change"></a><span data-ttu-id="b0bc3-107">什么是重大更改？</span><span class="sxs-lookup"><span data-stu-id="b0bc3-107">What is a breaking change?</span></span>

<span data-ttu-id="b0bc3-108">如果更改满足[列表 a](#list-a)中的任何条件并满足[列表 B](#list-b)中的所有条件，则更改是一项重大更改</span><span class="sxs-lookup"><span data-stu-id="b0bc3-108">A change is a breaking change if it satisfies any of the conditions in the [List A](#list-a) AND satisfies all of the conditions in [list B](#list-b)</span></span>

### <a name="list-a"></a><span data-ttu-id="b0bc3-109">列出 A</span><span class="sxs-lookup"><span data-stu-id="b0bc3-109">List A</span></span>

- <span data-ttu-id="b0bc3-110">添加、删除或更新任何接口的任何成员或函数 (或删除/重命名整个接口) 。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-110">The addition, removal, or update of any member or function of any interface (or removal/rename of the entire interface).</span></span>
- <span data-ttu-id="b0bc3-111">删除、更新 (更改类型/定义，使任何受保护的或公共成员或类函数的私有或内部) 。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-111">The removal, update (changing type/definition, making private or internal) of any protected or public member or function of class.</span></span> <span data-ttu-id="b0bc3-112">) 的整个类 (或删除/重命名。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-112">(or removal/rename of the entire class).</span></span>
- <span data-ttu-id="b0bc3-113">类激发的事件顺序的变化。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-113">The change in the order of events fired by a class.</span></span>
- <span data-ttu-id="b0bc3-114">重命名无相应 FormerlySerializedAs 标记) 或 ScriptableObject 上的公共属性的任何专用 SerializedField ( (特别是对配置文件) 的更改。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-114">The rename of any private SerializedField (without a corresponding FormerlySerializedAs tag) or public property on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="b0bc3-115">更改 ScriptableObject 上字段的类型 (对配置文件) 的更改尤其如此。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-115">Changing the type of a field on a ScriptableObject (especially changes to profiles).</span></span>
- <span data-ttu-id="b0bc3-116">对任何类或接口的命名空间或 asmdefs 的更新。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-116">Updates to the namespace or asmdefs of any class or interface.</span></span>
- <span data-ttu-id="b0bc3-117">删除 prefab 的顶层对象上的任何 prefab 或删除脚本。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-117">Removal of any prefab or removal of a script on the top level object of a prefab.</span></span>

### <a name="list-b"></a><span data-ttu-id="b0bc3-118">列表 B</span><span class="sxs-lookup"><span data-stu-id="b0bc3-118">List B</span></span>

- <span data-ttu-id="b0bc3-119">相关资产位于基础包中 (也就是说，它位于以下文件夹之一) ：</span><span class="sxs-lookup"><span data-stu-id="b0bc3-119">The asset in question is in the foundation package (i.e. it's in one of the following folders):</span></span>

  - <span data-ttu-id="b0bc3-120">MRTK/Core</span><span class="sxs-lookup"><span data-stu-id="b0bc3-120">MRTK/Core</span></span>
  - <span data-ttu-id="b0bc3-121">MRTK/提供程序/</span><span class="sxs-lookup"><span data-stu-id="b0bc3-121">MRTK/Providers/</span></span>
  - <span data-ttu-id="b0bc3-122">MRTK/Services/</span><span class="sxs-lookup"><span data-stu-id="b0bc3-122">MRTK/Services/</span></span>
  - <span data-ttu-id="b0bc3-123">MRTK/SDK/</span><span class="sxs-lookup"><span data-stu-id="b0bc3-123">MRTK/SDK/</span></span>
  - <span data-ttu-id="b0bc3-124">MRTK/Extensions</span><span class="sxs-lookup"><span data-stu-id="b0bc3-124">MRTK/Extensions</span></span>

- <span data-ttu-id="b0bc3-125">相关资产不属于实验命名空间。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-125">The asset in question does not belong to the experimental namespace.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b0bc3-126">位于示例包中的任何资产 (（即 MRTK/示例/文件夹) 的一部分）随时可以更改，因为使用者可以将其作为 "引用实现" 进行复制和查看，但不是 Api 和资产的核心集的一部分。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-126">Any asset that sits in the examples package (i.e. part of the MRTK/Examples/ folder) is subject to change at any time, as assets there are designed to be copied and viewed by consumers as 'reference implementations' but are not part of the core set of APIs and assets.</span></span> <span data-ttu-id="b0bc3-127">实验命名空间中的资产 (或更常见，标记为实验性) 的功能是在完成所有截止工作之前发布的功能 (例如，测试、UX 迭代、文档) 并及早发布，以便更快地获取反馈。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-127">Assets in the experimental namespace (or more generally, features labelled as experimental) are ones that get published before all due diligence has been done (i.e. tests, UX iteration, documentation) and is published early to get feedback sooner.</span></span>  <span data-ttu-id="b0bc3-128">不过，由于它们没有测试和文档，而且可能尚未明确所有交互和设计，因此，我们会将其发布到公共应假设它们可以和将更改 (即修改、完全删除等) 的状态。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-128">However, because they don't have tests and documentation, and because we likely haven't nailed down all of the interactions and designs, we publish them in a state where the public should assume that they can and will change (i.e. be modified, completely removed, etc).</span></span>
>
> <span data-ttu-id="b0bc3-129">有关详细信息，请参阅 [实验性功能](../contributing/experimental-features.md) 。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-129">See [Experimental features](../contributing/experimental-features.md) for more information.</span></span>

<span data-ttu-id="b0bc3-130">因为重大更改的外围应用非常大，所以请务必注意，具有显示 "无重大更改" 的绝对规则可能是不可能的，这可能是由于发生重大更改而只能通过合理方式解决的问题。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-130">As the surface area for breaking changes is very large, it's important to note that having an absolute rule that says "no breaking changes" would be impossible - there may be issues that can only be fixed in a sane way by having a breaking change.</span></span> <span data-ttu-id="b0bc3-131">作为另一种方法，我们真正可以说，"无重大更改" 是指根本不进行任何更改。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-131">To put another way, the only way we could really have "no breaking changes" is to have no changes at all.</span></span>

<span data-ttu-id="b0bc3-132">我们的主要策略是避免在可能的情况下进行重大更改，并且仅在更改会使重要的客户或框架长期价值时才会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-132">Our standing policy is to avoid making breaking changes if possible, and only do so if the change would accrue significant customer or framework long term value.</span></span>

## <a name="what-to-do-about-breaking-changes"></a><span data-ttu-id="b0bc3-133">如何应对重大更改</span><span class="sxs-lookup"><span data-stu-id="b0bc3-133">What to do about breaking changes</span></span>

<span data-ttu-id="b0bc3-134">如果可以在没有重大更改的情况下完成某个操作，并且不会影响长期的结构和生存能力，请不要执行重大更改。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-134">If it is possible to accomplish something without a breaking change and without compromising the long term structure and viability of the feature, don't do the breaking change.</span></span> <span data-ttu-id="b0bc3-135">如果没有其他方法，则当前策略是评估每个重大更改，以了解取得更改的好处是否超出了使用者吸收更改的成本。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-135">If there is no other way, the current policy is to evaluate each individual breaking change, to understand if the benefit from taking the change outweighs the cost to the consumer of absorbing the change.</span></span> <span data-ttu-id="b0bc3-136">探讨需要做什么，通常不会发生 PR 或问题讨论本身。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-136">Debate about what is worth doing and what isn't will generally take place on the PR or issue discussion itself.</span></span>

<span data-ttu-id="b0bc3-137">此处可能发生的情况分为几个 bucket：</span><span class="sxs-lookup"><span data-stu-id="b0bc3-137">What can happen here falls into several buckets:</span></span>

### <a name="the-breaking-change-adds-value-but-could-be-written-in-a-way-that-isnt-breaking"></a><span data-ttu-id="b0bc3-138">重大更改增加了值，但可以用不间断的方式编写</span><span class="sxs-lookup"><span data-stu-id="b0bc3-138">The breaking change adds value but could be written in a way that isn't breaking</span></span>

<span data-ttu-id="b0bc3-139">例如， [此 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) 添加了一项新功能，该功能最初是用一种被破坏的方式编写的，它修改了现有的接口，但随后又将该功能作为自己的接口被分解。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-139">For example, [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4882) added a new feature that was initially written in a way that was breaking - it modified an existing interface - but was then rewritten where the feature was broken out as its own interface.</span></span> <span data-ttu-id="b0bc3-140">这通常是可能的最佳结果。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-140">This is generally the best possible outcome.</span></span> <span data-ttu-id="b0bc3-141">如果执行此操作会危及功能的长期可用性或结构，则不要尝试更改为非中断形式。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-141">Do not try to force a change into a non-breaking form if doing so would compromise the long term viability or structure of the feature.</span></span>

### <a name="the-breaking-change-adds-sufficient-value-to-the-customer-that-its-worth-doing"></a><span data-ttu-id="b0bc3-142">重大更改为客户增加了足够的价值</span><span class="sxs-lookup"><span data-stu-id="b0bc3-142">The breaking change adds sufficient value to the customer that it's worth doing</span></span>

<span data-ttu-id="b0bc3-143">记录重大更改的内容，并提供最佳的缓解措施 (即，如何迁移或更好的工具将自动为客户) 进行迁移。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-143">Document what the breaking changes are and provide the best possible mitigation (i.e. prescriptive steps on how to migrate, or better yet tooling that will automatically migrate for the customer).</span></span> <span data-ttu-id="b0bc3-144">每个版本可能会包含少量重大更改，这些更改应始终记录在文档中，就像 [此 PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858)中所做的那样。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-144">Each release may contain a small amount of changes that are breaking - these should always be documented in docs as was done in [this PR](https://github.com/microsoft/MixedRealityToolkit-Unity/pull/4858).</span></span> <span data-ttu-id="b0bc3-145">如果已经有一个1.x： +1 + 1 迁移指南，请向该文档添加说明或工具。如果它不存在，请创建它。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-145">If there already is a 2.x.x→2.x+1.x+1 migration guide, then add instructions or tooling to that doc. If it doesn't exist, create it.</span></span>

### <a name="the-breaking-change-adds-value-but-the-customer-pain-would-be-too-high"></a><span data-ttu-id="b0bc3-146">重大更改增加了价值，但客户的痛苦会太高</span><span class="sxs-lookup"><span data-stu-id="b0bc3-146">The breaking change adds value but the customer pain would be too high</span></span>

<span data-ttu-id="b0bc3-147">并非所有类型的重大更改都是相同的，它们都是根据我们的经验和客户体验，更令人头疼。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-147">Not all types of breaking changes are created equal - some are significantly more painful that others, based on our experience and based on customer experiences.</span></span> <span data-ttu-id="b0bc3-148">例如，对接口所做的更改可能会令人头痛，但如果重大更改是客户不太可能在过去 (诊断可视化系统（如) ）的情况下进行扩展</span><span class="sxs-lookup"><span data-stu-id="b0bc3-148">For example, changes to interfaces may be painful, but if the breaking change is one in which a customer is unlikely to have extended/implemented in the past (the diagnostic visualization system, for example), then the actual cost is probably low to nothing.</span></span> <span data-ttu-id="b0bc3-149">但是，如果更改是 ScriptableObject 上某个字段的类型 (例如，在) MRTK 的一个核心配置文件上，这可能会导致巨大的客户难题。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-149">However, if the change is the type of a field on a ScriptableObject (for example, on one of the core profiles of the MRTK), this is likely to cause massive customer pain.</span></span> <span data-ttu-id="b0bc3-150">客户已经克隆了默认配置文件，合并/更新配置文件可能非常难以手动执行 (即，在合并期间通过文本编辑器) ，并重新复制默认配置文件并重新配置所有内容，这极有可能导致难以调试回归。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-150">Customers have already cloned the default profile, merging/updating profiles can be extremely hard to do manually (i.e. via a text editor during merge time), and re-copying the default profile and reconfiguring everything by hand is extremely likely to lead to hard to debug regressions.</span></span>

<span data-ttu-id="b0bc3-151">必须将这些更改放回到托架上，直到存在一个分支存在，这将导致重大更改 (以及将为客户提供升级) 的重要价值。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-151">These changes we have to put back onto the shelf until a branch exists that will allow significantly breaking changes (along with significant value that will give customers a reason to upgrade).</span></span> <span data-ttu-id="b0bc3-152">此类分支当前不存在。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-152">Such a branch doesn't currently exist.</span></span> <span data-ttu-id="b0bc3-153">在我们未来的迭代规划会议中，我们将回顾一组 "过于严重" 的更改/问题，以确定我们是否达到了一项关键的质量，以便能够合理地执行一组更改。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-153">In our future iteration planning meetings, we will review the set of changes/issues that were 'too breaking' to see if we reached a critical mass to make it reasonable to pursue a set of changes all at once.</span></span> <span data-ttu-id="b0bc3-154">请注意，由于我们拥有的工程资源有限，因此，启动 "一切都是允许的" 分支，而不是由于有限的工程资源而进行</span><span class="sxs-lookup"><span data-stu-id="b0bc3-154">Note that it's dangerous to spin up a "everything is allowed" branch without due diligence being done because of the limited engineering resources we have, and the fact that we'd have to split testing and validation across those two.</span></span> <span data-ttu-id="b0bc3-155">此类分支存在时，需要有一个明确的用途和良好的通信开始和结束日期。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-155">There needs to be a clear purpose and well-communicated start and end date of such a branch when it exists.</span></span>

## <a name="long-term-management-of-breaking-changes"></a><span data-ttu-id="b0bc3-156">重大更改的长期管理</span><span class="sxs-lookup"><span data-stu-id="b0bc3-156">Long term management of breaking changes</span></span>

<span data-ttu-id="b0bc3-157">从长远来看，我们应该设法通过增加 [列表 B](#list-b)中的条件集来减少重大更改的范围。今后，在 [列表 A](#list-a) 中进行一组任务，对于我们认为位于 "公共 API 图面" 的一组文件和资产，将始终中断。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-157">In the long term, we should seek to reduce the scope of what is a breaking change by increasing the set of conditions in [List B](#list-b). Going forward the set of things in [List A](#list-a) will always technically be breaking for the set of files and assets that we deem to be in the "public API surface."</span></span> <span data-ttu-id="b0bc3-158">我们可以更自由地利用迭代 (例如，通过更改内部实现详细信息，以便更轻松地在多个类之间重构和共享代码，如) 更明确地说明代码的哪些部分是官方面，而不是实现详细信息。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-158">The way that we can get a little more freedom for iteration (i.e. changing up the internal implementation details, allowing for easier refactoring and sharing of code between multiple classes, etc) is to be more explicit about which portions of the code are official surface, rather than implementation detail.</span></span>

<span data-ttu-id="b0bc3-159">我们所做的一件事就是介绍了 "实验性" 功能 (的概念，该功能在实验命名空间中存在，它可能没有测试/文档，而且可能会被删除并更新，而不) 警告。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-159">One thing we've already done is introduce the concept of an "experimental" feature (it belongs in the experimental namespace, it may not have tests/documentation, and is publicly proclaimed to exist but may be removed and updated without warning).</span></span> <span data-ttu-id="b0bc3-160">这样，就可以自由地添加新功能来更早地添加新功能，但不能立即将其绑定到 API surface (，因为我们可能未) 充分考虑 API 图面。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-160">This has given has freedom to add new features sooner to get earlier feedback, but not be immediately tied to its API surface (because we may not have fully thought out the API surface).</span></span>

### <a name="other-examples-of-things-that-could-help-in-the-future"></a><span data-ttu-id="b0bc3-161">将来可能会有所帮助的其他一些示例</span><span class="sxs-lookup"><span data-stu-id="b0bc3-161">Other examples of things that could help in the future</span></span>

- <span data-ttu-id="b0bc3-162">[内部关键字](/dotnet/csharp/language-reference/keywords/internal)的用法。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-162">Usage of the [internal keyword](/dotnet/csharp/language-reference/keywords/internal).</span></span>
  <span data-ttu-id="b0bc3-163">这样，我们就可以在自己的程序集中使用共享代码 (用于减少代码重复) 而无需向外部使用方公开任何东西。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-163">This would allow for us to have shared code within our own assemblies (for reducing code duplication) without making things public to external consumers.</span></span>
- <span data-ttu-id="b0bc3-164">创建 "内部" 命名空间 (例如 MixedReality。Toolkit。内部实用程序) ，我们在其中公开了该内部命名空间中包含的所有内容，随时都可以更改和删除，等等。这类似于 c + + 标头库如何使用：：内部命名空间来隐藏其实现细节。</span><span class="sxs-lookup"><span data-stu-id="b0bc3-164">Creation of an "internal" namespace (i.e. Microsoft.MixedReality.Toolkit.Internal.Utilities), where we publicly document that anything contained within that internal namespace is subject to change at anytime and could be removed, etc. This is similar to how C++ header libraries will make use of ::internal namespaces to hide their implementation details.</span></span>
